1) Начинаем цикл for по переменной x в пределах от 10**(N)-1 до 10**(N-1)
(например, для N=3 переменная x будет изменяться в пределах от 999 до 100, перебирая все трёхзначные числа)

2) Заводим переменную dig_sum=0, в которую будем складывать сумму цифр числа

3) Создаём копию x_copy переменной x. Циклом while, пока x_copy больше нуля, добавляем к dig_sum последнюю цифру числа x_copy (остаток от деления на 10) и убираем эту цифру из числа (целочисленно делим его на 10)

4) Если сумма чётна или делится на 3 (остаток при делении на 2 или на 3 есть ноль), сумма не простая и цикл for идёт на следующую итерацию (можно перебрать деление на другие простые множители для дополнительного ускорения программы в случае больших N, но для простоты будем делать только 2 проверки)

5) Если же сумма dig_sum не делится ни на 2, ни на 3, то пробегаемся циклом for по переменной divisor от 5(делимость на 2, 3 была проверена ранее) до dig_sum, и если dig_sum делится на div нацело (остаток равен нулю), то dig_sum – составное число и цикл идёт на следующую итерацию (для проверки успешности можем завести соответствующий флаг или воспользоваться ключевым словом continue)
   
   Важно! На шаге 5 вместо использования цикла можно запомнить список первых простых чисел и пробегаться по нему (максимальная сумма цифр есть 9\*19=171, значит, мы затратим дополнительно O(171)  = O(1) памяти)

6) Наконец, если мы не нашли ни одного делителя числа dig_sum (флаг не переключился или мы дошли до конца цикла минуя continue), то искомое число найдено. Печатаем число и останавливаем цикл (оператор break)
   
Затраты по памяти: O(1)
Затраты по времени: O(10\*\*n)