# JS
#prog  #web #course |  [[Web]] [[Prog]] [[Course]]
Онлайн-учебник
> [!bug]- Шпаргалка
> **Режим разработчика**
> *IE, Firefox* `F12`
> *Chome* `F12` (`cmd+option+J`)
> *Safari* `cmd+option+C`
- - -
&nbsp;
## Полезные ссылки

> [!important]- Официальная документация
https://www.ecma-international.org/publications-and-standards/standards/ecma-262/

> [!important]- Учебник
https://learn.javascript.ru

> [!important]-  MDN -  онлайн-справочник
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference

> [!important]-  Таблица совместимостей
https://caniuse.com

> [!important]-  Системные символы
https://tc39.es/ecma262/#sec-well-known-symbols
- - -
&nbsp;
## Основы

Скрипты JS очень просто интегрируются в HTML код. Для этого используется тег `<scipt>`

Если у нас много кода, можно поместить его в отдельный файл и приписать имя файла в качестве атрибута `src` для тега
```HTML

<scipt src="/path/to/script.js">
	</scipt>
```

В данном случае был указан абсолютный путь, но можно указывать и относительный

>[!done]- Разбитие на файлы это хорошо
>Помимо удобства работы, скачанные скрипты сохраняются браузером в кеш, и если другая страница захочет вызвать тот же скрипт, вызовется скрипт из кеша, что ускорит сайт и уменьшит траффик

>[!warning]- Важно
>Если установлен атрибут `src`, то содержимое тега будет игнорироваться. Поэтому если хочется и исполнить скрипт в файле, и написать свой прямо в html документе,  сделать это можно только через два отдельных тега

&nbsp;
> [! danger]- Точка с запятой
 Точка с запятой разделяет команды, поэтому их можно (но не нужно) писать в одну строку. Однако при этом почти всегда точка с запятой ставится автоматически
 https://tc39.github.io/ecma262/#sec-automatic-semicolon-insertion
 но, если вкратце, то JS делает это непредсказуемо и лучше их ставить явно
 
 > [! danger]- Комментарии
 > *C-style*
 > ```JS
 > 
 > // Однострочник
 > 
 > /*
 > много
 > строчник
 > */
 > ```

&nbsp;
### Use strict

Для обратной совместимости по умолчанию JS работает в "старом" режиме. Чтобы переключиться на "современный", или строгий режим с новыми функциями и переделанными старыми, нужно написать *"use strict"* в начале файла. Позже эту операцию нельзя будет отменить

>[!warning]- Strict для функций
>строку можно написать в начале функции. Тогда строгий режим будет в рамках этой функции

>[!warning]- Начало файла
>*"use strict"* должно стоять в **первой**  строке файла или функции. До *"use strict"* могут стоять только комментарии

&nbsp;
### Переменные

Объявление переменной:
```JS

let x = 3;
```
```JS

let x;
x = 3;
```

Можно объявлять несколько переменных в одной строке:
```JS

let x = 3, name = 'Vladislav';
```

Имена переменных регистрозависимы:
```JS

let perem = 10;
let Perem = 20;
alert(perem); // 10
```

Для определения неизменеяемых переменных вместо `let` используется `const`
```JS

const x = 3;
x = 5; // Error
```

&nbsp;
>[!warning]-  Ограничения
> 1. Имя переменной может содержать **только** буквы, цифры и символы `$`, `_`
> 2. Имя не может начинаться с цифры

> [!info]-  Про strict mode
> В строгом режиме нельзя инициализировать переменную без кодового слова "let". В обычном режиме можно
> ```JS
> x = 3;
> ```

>[!tip]- Список зарезервированных имён
>https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#ключевые_слова

&nbsp;
### Типы данных
В JS типизация динамическая (не считая всякие *TypeScript*). Перечислим основные типы данных:

**number**
Представляет как целые, так и дробные числа
```JS

x = 123;
x = 123.09123;
x = Infinity;
x = NaN;
```

**BigInt**
Числа произвольной длины, без ограничения, пишется с буквой `n` на конце
```JS

x = 123236724152176542764526745n;
```

**string**
Строка, заключенная в кавычки (одиночные, двойные или *обратные*)
```JS

let str1 = "Обычная строка";
let str2 = 'Не менее обычная строка';
let str3 = `Обратные кавычки допускают ${str1} форматирование`;
```

**boolean**
```JS

let flag1 = true;
let flag2 = false;
```

**null**
В JS `null` это не нулевой указатель, а просто отдельное значение, указывающие на то, что значение переменной неизвестно
```JS

let x = null;
```

**undefined**
Аналогично `null`. Причем если переменная была объявлена, но не определена, то ей присваевается именно `undefined`
```JS

let x = undefined;
```

**object**
`pass`

**symbol**
`pass`

>[!warning]- typeof
>Чтобы узнать тип переменной, используется `typeof`, причем как со скобками, так и без
> ```JS
> 
> let num = 123;
> let num2 = 123.231521;
> let bigint = 12324n;
> let flag = true;
> let str = 'Hello'
> let empty = null;
> let undef;
> 
> alert(`${typeof num}`) // number
> alert(`${typeof num2}`) // number
> alert(`${typeof bigint}`) // bigint
> alert(`${typeof flag}`) // boolean
> alert(`${typeof str}`) // string
> alert(`${typeof empty}`) // object
> alert(`${typeof undef}`) // undefined
> ```


### Взаимодействие (alert, prompt, confirm)

Как мы уже знаем, функция `alert(message)` нужна чтобы открыть *модальное* окно (то есть такое, которое блокирует доступ ко всем остальным процессам, пока ты не разберешься с ним). Например
```JS

alert('Hello!');
```

 Чтобы в таком же модальном окне запросить у пользователя значение, используйте функцию `prompt(title, [default])`. Она принимает на вход заголовок, просит человека ввести какое-то число и, если указано, изначально ставит туда значение по умолчанию
 
```JS

let age = prompt('Сколько тебе лет', 18);
alert('Тебе ${age} лет');
```

Чтобы задать пользователю вопрос типа да/нет в модальном окне, можно использовать функцию `	confirm(answer)`. Возвращает `true`/`false` в зависимости от ответа
```JS

let isBoss = confirm("Ты здесь главный?");
alert( isBoss ); // true, если нажата OK
```

&nbsp;
### Преобразование типов

Приведение типов происходит само по себе, но если мы хотим явно указать тип значения. Рассмотрим какие приведения типов бывают (обычно это просто вызов функции как в питоне)

Чтобы привести объект `non_string` к строке, используем 
```JS

String(non_string)
```
Чтобы привести объект `non_number` к числу, используем 
```JS
Number(non_number)
```
**Правила численного преобразования**:
- `undefined` $\rightarrow$ `NaN`
- `null` $\rightarrow$ `0`
- `true/false` $\rightarrow$ `1/0`
- `string` $\rightarrow$ обрезаем пробелы по краям. Если осталась пустая строка то 0, иначе если можем считать число то это число, иначе `NaN`

Чтобы привести объект `non_boolean` к логическому типу, используем 
```JS
Boolean(non_boolean)
```
- - -
&nbsp;
### Операции
Абсолютно питонячьи, но с сишными  `++`

&nbsp;
**Основные операции**
```JS

++ // инкремент
-- // декремент
+ // унарный/бинарный плюс
- // унарный/бинарный минус
* // умножить
/ // деление
% // остаток
? // тернарный оператор
** // степень
*= // умножить с присваиванием
+=
-=
/=
// и так далее
```

- Строки так же объединяются через плюс
- Инкремент/декремент так же бывают в префиксной форме (перед переменной)
- Тернарный оператор используется через `условие ? yes_case : no_case`

> [!warning]- Унарный плюс
> Унарный плюс не меняет число, однако нечисловое значение он приводит к числовому. То есть действие `+string` будет таким же, что и  `Number(string)`, но запись короче

&nbsp;
**Логические операции**
C-style
```JS
|| // OR
&& // AND
! // NOT
?? // оператор нулевого слияния
```
- Оператор нулевого слияния `a ?? b` возврашает `a`, если она не `null` и не `undefined`, иначе возвращает `b`

&nbsp;
**Битовые операции**

```JS

& // AND
| // OR
^ // XOR
~ // NOT
<< // левый сдвиг
>> // правый сдвиг
>>> // правый сдвиг с заполнением нулями
```

&nbsp;
**Операторы сравнения**
```JS

=== // строгое равенство (без приведения типов)
== // обычное равенство
>=
<=
!=
```

- Строки сравниваются лексикографически
- При сравнении через `==` все операнды приводятся к числу, поэтому  `'' == false` приведет и строку, и логическую переменную к числу 0

&nbsp;
### If else
Вместо тысячи слов:
```JS

if(year == 2015) do_something();
// однострочник

if(year == 2015) {
	do_something();
	do_something();
} else if(year <= 2014) {
do_something();
} else {
	final_case();
}
```

&nbsp;
### While  for
Вместо тысячи слов (чистый C-style):
```JS

while(x < 3) x++;
// однострочник

while(x < 3){
	x++;
	do_something();
}
```

```JS

for(let i = 3; i < 10; i++)
{
	do_something();
}
```

`break` ломает цикл
`continue` продолжает цикл

> [! warning]- Метка цикла
> Что если хочется выйти не из ближайшего цикла, а сразу из более внешнего цикла. Для этого перед любым циклом можно написать метку
> ```JS
> 
> cool_cycle: for(; x < 3; x++)
> {
>     break cool_cycle;
> }
> ```
> Тогда вызов `break` с указанием этой метки закроет именно этот цикл. Аналогично, вызов `continue` тоже работает с метками

&nbsp;
### Switch
Опять C-style
```JS

switch(x){
	case(3):
		do_something();
		break;
	case(2):
		do_something();
		break;
	case(1):
		do_something();
		break;
	default:
		break;
}	
```

- Проверка на равенство всегда строгая (`===`), поэтому приведение типов нужно сделать самому

&nbsp;
### Функции
Вместо типа возвращаемого значения тут `function`

```JS

function summ(a=2, b=3){
	return a + b;
}
```

- Без значений по умолчанию переменной присваивается `undefined`
- Функция имеет полный доступ ко всем глобальным переменным (созданным вне функций) и может их менять
- Функция может локально переопределить имя глобальной переменной, тогда изменения не затронут глобальную
- Неизменяемые объекты (числа, строки) передаются по ссылке, изменяемые по значению (массивы, объекты)

> [! warning]- Функции-колбеки
> Просто функции, передаваемые в качестве аргумента. Их синтаксис крайне прост:
> ```JS
> 
> function func(statement, func1, func2){
>     if(statement) func1();
>     else func2();
> }
> ```

> [! warning]- Function expression
> Можно присвоить переменной функцию
> ```JS
> 
> let sum = function(a, b) {
>    return a + b; 
> }
> ```

> [! warning]- Стрелочные функции
> Стрелочная функция считает выражение, указаное после стрелки и возвращает его. По сути это функция однострочник
> 
>  ```JS
> 
> function sum(a, b) => a + b;
> ```
> Конечно, есть и другие особенности, но об этом в отдельной главе
- - -

&nbsp;
## Объекты

Объекты, в отличии от остальных семи "примитивных" типов данных хранят целую коллекцию значений и сущностей. Объект можно задать фигурными скобками, в которых по желанию перечислить свойства синтаксисом `name:value`.

 По сути объект -- это классический словарь ключ-значение. Пример
```JS

let user = { name:'Jonh', age:30 };
alert(user.name) // 'John'
```

Для добавления любого ключа просто определяем его

```JS

user.some_info = 12345;
alert(user.some_info); // 12345
```

Для удаления ключа используем `delete`
```JS

delete user.some_info;
```

Есть альтернативный способ обращаться по ключу, через квадратные скобки. Правда тогда нужно писать ключ в кавычках
```JS
alert(user["name"]); // John

```
Проверить существование ключа можно через `in`, также через кавычки. А можно просто сравнить результат с `undefined` 
```JS

user.blablabla === undefined; // true
"blablabla" in user; // false
```

Проверка через `in` читается лучше и работает без сбоев, даже когда объект существует, но его значение `undefined`
&nbsp;
Можно пробегаться по объекту массивом `for`, так же, как и итератором в питоне
```JS

for (let key in user) {
	alert(key);
}
```

&nbsp;
### this

Объекту в качестве значения ключа можно присвоить функцию. Тогда в рамках этой функции можно обращаться к полям объекта через `this`

```JS
 
 user = { name : 'John', age : 23};
 user.say_hello = function {
 	alert('Hello, I am ${this.name}');
 }
 ```
 Вообще, `this` применимо в любой функции и будет указывать на объект, из под которого запускается функция.
 
 А еще у стрелочных функций нет своего `this` и они наследуют его извне. В каком-то смысле это `inline`
 
 &nbsp;
###  Функция-конструктор

Иногда хочется создать не один объект, а сразу много. Тогда пригодится знать как создавать объекты с помощью функции. Для этого используется слово `new` (и все еще никакого управления памятью). После `new` идет написанная функция-конструктор, которая принимает в себя аргументы, а в качестве `this` берет только что созданный объект.

Например
```JS

function CreateUser(name, age){ // начинается всегда с большой буквы
	this.name = name;
	this.age = age;
}

user1 = new CreateUser('John', 23);
```

Еще раз заметим, что название такой функции начинается с большой буквы

> [!tip]-  target
> Если внутри функции написать `new.target`, то в качестве значения мы получим саму функцию, если ее вызов был с помощью `new`, и `undefined` если без `new`
> 
> Таким образом можно отделять поведение для функции в зависимости от того, как она вызвана
> ```JS
> 
> function User(name){
>    if(!new.target) { // если вызвана без new
>        return new User(name); // добавляем оператор сами
>    }
>    this.name = name;
> }
> ```

Обычно конструктор ничего не возвращает, их задача записать всё в `this`, который неявно возвращается. Однако если все же написать внутри конструктора `return`, то выполняется простое правило -- *Если возвращается объект, то мы вернем его, а не this. Однако если возвращается что-то другое, то вернем this и проигнорируем это примитивное значение*.  Поэтому имеет смысл возвращать только то, какой объект мы хотим создать, а во многих случаях писать `return` вообще нет необходимости и достаточно проставить значения для полей объекта `this` 

> [!tip]- ?.
> Часто хочется обратиться к полю объекта, или к полю поля объекта, и при этом если оно `undefined` не получить ошибку (а она возникает). Недавно добавленная возможность – это обращаться к полям, которые не факт, что существуют, через `?.`
> 
> Этот оператор работает как `.`, если объект **слева** от него существует, а если его нет молча возвращает `undefined` без вызова ошибки
> 
> Например, код
> ```JS
> 
> alert( user?.address?.street);
> ```
> Сработает без ошибки даже в случае, если нет юзера
> 
> Ну а еще этот же синтаксис работает при вызове функций объекта или при обращении к полю через квадратные скобки
> ```Js
> 
> userAdmin.admin?.();
> alert(user1?.[key]);
> ```
> При этом надо помнить, что пользоваться этим оружием нужно **только** тогда, когда отсутвие поля нормально. Иначе ловить ошибку будет трудно и долго
> 

&nbsp;
### Symbol
По спецификации, в качестве ключей объектов могут выступать только строки и *символы*. Что же это за зверь такой?

По сути, символ – это уникальный айдишник с названием, который гарантированно не пересечется с другим ключем (даже если у них будут совпадать названия). Чем-то напоминает мне `enum` в плюсах, тоже генерирует уникальный ключ и не подразумевает что ты будешь смотреть его значение

Конкретнее, символ создается соответсвующей функцией, куда в качестве параметра можно добавить имя символа

```JS

let id = Symbol();
let named_id = Symbol("named_id");
```

Символы гарантированно уникальны, поэтому даже символы с одним именем будут различаться
```JS

let new_named_id = Symbol("named_id");
alert(named_id == new_named_id); // false
```

> [!warning]- Символы и строки
> Символы **не** преобразуются в строки автоматически. Считается, что это два принципиально разных типа данных. Поэтому для написания символа надо явно приводить его к строке. Можно использовать встроенный метод  `toString`  или вывести поле `description` (это и есть название символа)
> 
> ```JS
> 
> let id = Symbol("NAME");
> 
> alert(id); // ошибка
> alert(String(id)); // Symbol(NAME)
> alert(id.toString()); // Symbol(NAME)
> alert(id.description); // NAME
> ```

Традиционно считается, что символы обозначают приватные поля объекта, которые не надо вызывать. Если хочется проставить символ при объявлении объекта в фигурных скобках, можно сделать так

```JS

let id = Symbol('id');

let user = {
	name: "Вася",
	[id]: 123, // создали ключ с символом
};
```

>[!warning]- Символы и циклы
>Если проходится циклом `for` по всем ключам объекта, то он не будет пробегать по символам. Считается, что символы приватны и что они не нужны для использования во внешнем интерфейсе.
>
>При этом при копировании объекта через `Object.assign` копирует все свойства. Потому что нам нужно склонировать объект целиком, со всей внутренней логикой

&nbsp;
#### Глобальные символы
Символ можно определять глобально, и всей программой пользоваться одними и теми же символами. Для этого используется синтаксис
```JS

Symbol.for(name);
```

Если ключ существовал, то он вернется этой функцией, а если не существовал, то создастся.

Существует множество символов языка, работающих под капотом и похволяющих нам проводить необходимые настройки. Вот их список
https://tc39.es/ecma262/#sec-well-known-symbols



