### Навыки

- [x] array
- [x] zeros, ones, empty

- [x] .ndim .shape .size
- [x] .dtype
- [x] astype

- [x] axis

- [x] arr[idx]
- [x] arr[idx1, idx2]
- [x] arr[slc]
- [x] arr[slc1, slc2]

- [x] : * + -
- [x] ** power sqrt
- [x] exp
- [x] round

- [x] reshape
- [x] flatten
- [x] transpose, T

- [x] mean
- [x] median
- [x] min, max
- [ ] argmin argmax
- [x] mode
- [x] var, std


### Введение

В современном мире определяющую роль играют данные, а понимание, как эти данные устроены и по каким законам работают величины, на первый взгляд кажущиеся совершенно случайными и неструктурируемыми, очень ценится. В этом нелёгком, но очень увлекательном деле человечеству помогает статистика — наука о закономерностях в данных и о том, какими математическими моделями их описывать. Статистика помогает в принятии бизнес-решений, анализе рисков, поиске инсайдов в больших данных и машинном обучении.

Начало нашего пути в освоении статистики и анализа данных пройдёт через библиотеку Numpy — фундаментельный инструмент для работы с массивами данных в Python. Мы начнём с основ этой библиотеки, научимся базовым действиям, таким как применение арифметических операций, индексирование и аггрегация, а также изучим основы статистики, которые позже разовьём в полноценную практическую теорию. 

Наше изучение Numpy будет разделено на два занятия. На втором занятии мы пройдём те оставшиеся необходимые функции и возможности, которые не затронем здесь, а также разберём более сложные статистики на примерах с кодом. Желаем тебе удачи в освоении этой увлекательной науки и надеемся, что это путешествие окажется для тебя таким же увлекательным, каким когда-то оказалось для команды курса!
### Создание массивов и их атрибуты
##### Напоминание об ООП

Перед тем как погружаться в особенности Numpy повторим основы объектно-ориентированного программирования (ООП). Numpy, как и многие другие инструменты науки о данных, является **библиотекой** — подключаемым к коду модулем, содержащим полезные функции и классы. в Python библиотеки подключаются с помощью команды `import`
```Python
import numpy as np
```
Традиционно при подключении Numpy дают псевдоним `np`. Теперь, пользуясь псевдонимом, мы можем через точку обращаться к различным объектам библиотеки. Среди них конкретные объекты, такие как число пи
```Python
np.pi # 3.1415926...
```
И классы, такие как класс массива чисел `np.array`. Как и при работе с другими классами в Python, для создания **представителя** класса необходимо запустить инициализацию, дописав к имени класса скобки
```Python
# Класс
np.array

# Конкретный представитель класса, массив чисел
np.array()
```

Когда мы создали представителя класса, мы можем взаимодействовать с ним, производя действия с его внутренними значениями, **полями**, или вызывая его внутренние функции, **методы**. Так, у представителей `np.array` есть поле `dtype`, показывающее тип хранящихся в массиве данных, и метод `reshape`, менящий форму массива
```Python
# Создаём массив
arr = np.array()

# Получаем тип хранимых данных с помощью поля
dtype = arr.dtype 

# Меняем форму массива с помощью метода
arr.reshape(-1)
```

Заметил аргумент -1 внутри функции reshape? О его назначении и принципах работы этих полей и методов мы подробно поговорим ниже. 

Теперь, когда мы вспомнили основные понятия ООП, давай начнём изучение Numpy. Путь в тысячи ли начинается с первого шага, и нашим первым шагом будет создание массива данных

##### Инициализация массива и его форма

Как было сказано выше, для хранения данных в Numpy используется класс np.array. При его инициализации можно подать на вход коллекцию чисел (список или кортеж) и получить массив сразу из нужных значений

```Python
import numpy as np

arr = np.array([1,2,3,4,5])
# [1 2 3 4 5]
```

Numpy отлично работает с многомерными массивами (массивами, состоящими из массивов), поэтому при инициализации np.array можно подать на вход в том числе вложенный список

```Python
arr_2d = np.array([[1,2], [3,4], [5,6]])
# [[1 2] 
#  [3 4] 
#  [5 6]]
```

Мы создали двумерный массив, который можно интерепретировать как таблицу чисел размера 3x2. Из курса линейной алгебры ты узнаешь, что такие таблицы называются матрицами и поймёшь, как много у этого объекта полезных применений! А пока давай получим размер этого массива с помощью Numpy. Для того, чтобы выяснить количество измерений в массиве (степеней вложенности) достаточно просто посмотреть на поле `ndim`

```Python
arr_2d = np.array([[1,2], [3,4], [5,6]])

arr_2d.ndim
# 2
```

Наш массив действительно имеет два измерения. А для того чтобы выяснить, какое количество объектов лежит вдоль каждого из измерений, используется одно из самых популярных полей `np.array` — `shape`

```Python
arr_2d = np.array([[1,2], [3,4], [5,6]])

arr_2d.shape
# (3, 2)
```

Действительно, размер нашей таблицы чисел был равен 3x2. Заметим, что результат выдаётся в виде кортежа — так сделано потому что для формы массива критически важен порядок чисел. Для таких объектов традиционно используют кортеж, а не список, из-за его неизменяемости.

Наконец, давайте посчитаем общее количество элементов в массиве. Школьные знания подсказывают нам, что для этого нужно просто перемножить длины всех размерностей, то есть посчитать произведение элементов `np.shape`. Это действительно так, однако делать это вручную для многомерного массива может быть очень сложно. Специально для этого у `np.array` есть поле `size`

```Python
arr_2d = np.array([[1,2], [3,4], [5,6]])

arr_2d.size
# 6
```

В реальных задачах, связанных со статистическим анализом, машинным обучением или эконометрикой, размерность массива может достигать десятков и сотен измерений, а общее число значений исчисляться миллионами. В таких случаях ручная проверка уже не поможет, и поля `size`, `shape` и `ndim` становятся действительно незаменимыми

```Python
# Пример пятимерного массива. 
# Определить его форму "вручную" сложнее, чем посмотреть поле shape

# [[[[[0. 0. 0. 0.]
#     [0. 0. 0. 0.]] 
#
#     [[0. 0. 0. 0.]
#      [0. 0. 0. 0.]] 
#
#     [[0. 0. 0. 0.]
#      [0. 0. 0. 0.]] 
#
# 
#     [[0. 0. 0. 0.]
#      [0. 0. 0. 0.]] 
#
#     [[0. 0. 0. 0.]
#      [0. 0. 0. 0.]] 
#
#     [[0. 0. 0. 0.]
#      [0. 0. 0. 0.]]]]]
```

##### Массивы регулярного вида

Иногда вместо создания массива из строго заданных значений бывает удобнее создать массив более простой структуры — из нулей, единиц или даже пустых значений, не заполненных ничем конкретным

Для создания массива из нулей используется функция `np.zeros()`. В качестве аргумента эта функция принимает на вход желаемую форму массива — всё так же в формате кортежа

```Python
arr_0 = np.zeros((3, 4))
# [[0. 0. 0. 0.]
#  [0. 0. 0. 0.]
#  [0. 0. 0. 0.]]
```

Аналогично, для создания массива из единиц, используется функция `np.ones()`

```Python
arr_1 = np.ones((2, 1, 3))
# [[[1. 1. 1.]] 
#
#  [[1. 1. 1.]]]
```

Если же необходимо создать пустой массив, то есть массив, в которой явно не записываются никакие значения, используется метод `np.empty()`

```Python
arr_emp = np.empty([2, 2])
# [[ -9.74499359e+001,   6.69583040e-309],
#  [  2.13182611e-314,   3.06959433e-309]])
```

В этом случае Numpy просто выделит память под нужный массив, но не будет записывать туда никакие значения. Полученные данные могут быть как упорядоченными, так и хаотичными — это зависит от того, какие значения записал туда последний процесс, работавший с этой областью памяти 



##### Типы данных и работа со значениями

Заметил, что в последних примерах данные сохранялись в дробном формате, а в первых примерах мы наоборот создавали массивы из целых чисел? Давай разберёмся с тем, как получать информацию о типе данных и изменять его

Если ты хочешь узнать тип данных массива, просто выведи поле `dtype` (data type). Создадим массив из целых чисел и выведем тип данных, в котором он хранится. Логично предположить, что результат будет в формате `int`

```Python
arr_int = np.array([3, 10])

arr_int
# [3, 10]

arr_int.dtype
# int64
```

Отлично, мы выяснили тип данных нашего массива! Оказывается, numpy хранит наши данные в формате `int64` (целочисленный формат, хранящий число в 64 битах). У Numpy есть целое множество внутренних типов данных и правил перевода из этих типов данных в другие, однако для всех наших задач будем считать, что тип данных `np.int64` идентичен типу `int` из стандартного Python

Что насчёт дробных чисел? Чтобы понять, в каком формате Numpy их сохраняет, создадим массив с дробными значениями, например числами $e$ и $\pi$, причём сделаем это с помощью констант из самой библиотеки Numpy

```Python
# массив из числа е и числа пи
arr_float = np.zeros((np.e, np.pi))

arr_float
# [2.71828183 3.14159265]

arr_float.dtype
# float64
```

По аналогии дробные числа хранятся в формате `np.float64`. 

Нужный тип данных можно задать сразу при инициализации с помощью необязательно аргумента dtype — это работает как со стандартной инициализацией `np.array()`, так и с `np.zeros()`, `np.ones()` и `np.empty()`

```Python
arr_1 = np.array([np.e, np.pi])
# [2.71828183 3.14159265]

# Тот же массив, но с типом данных np.int64
arr_2 = np.array([np.e, np.pi], dtype=np.int64)
# [2 3]

zeros_1 = np.zeros((2))
# [0. 0.]

# Тот же массив, но с типом данных np.int64
zeros_2 = np.zeros((2), dtype=np.int64)
# [0 0]
```

При этом тип данных массива можно менять и на ходу. Для этого используется метод `astype`, в котором в качестве аргумента указывается нужный тип данных для данного массива

```Python
# массив из числа е и числа пи
arr_float = np.zeros((np.e, np.pi))
# [2.71828183 3.14159265]

# Тип данных будет отличаться!
arr_float.astype(np.int64)
# [2 3]
```

У нас успешно получилось перевести числа из дробного формата `np.float64` в целочисленный `np.int64`. 

Приведём другой пример. Как мы выяснили выше, Numpy по-умолчанию хранит дробные числа в формате `np.float64`, предоставляющем большую точность вычислений:

```Python
arr = np.array([np.pi, np.e])
# [3.14159265 2.71828183]
```

Однако иногда эта точность избыточна. В таком случае разумно перевести значения в более компактный формат, потеряв часть информации о дробной части числа

```Python
# Перевод из float64 во float16
arr.astype(np.float16)
# [3.14 2.719]
```

Как мы видим, при хранении чисел в 16 битах вместо 64 точность вычислений падает, зато хранимое место уменьшается в 4 раза! Метод `astype()` удобен и практичен, однако при всём его удобстве следует помнить, что он работает "не на месте"
##### На месте VS Не на месте

Для работы с данными в Python критически важно разобраться в одном ньюансе работы методов и функций

Дело в том, что все методы и функции, изменяющие данные, по своей природе делятся на два типа:
- Те, что делают это "на месте" (in-place), то есть изменяют объект, с которым работали
- Те, что делают это "не на месте" (out-of-place), то есть не изменяют объект, с которым работали, а вместо этого создают новый объект, в котором лежат изменённые данные

Для того, чтобы разобраться в разнице между этими типами преобразований, рассмотрим стандартный список в Python и два способа отсортировать его — `sorted()` и `.sort()`

 - При применении метода `.sort()` мы меняем тот объект, с которым работали. Так как кроме этого от метода `.sort()` ничего не требуется, этот метод ничего не возвращает в качестве результата своей работы. В этом нет необходимости, так как список уже изменён и отсортирован!
 
```Python
# Создаём список
l = [3,1,5,4,2]

# Применяем метод .sort() и сохраняем результат его работы
result = l.sort()

print(l, result)
# [1,2,3,4,5] None
```

Видим, что результат оказался пустым, поскольку свою цель `.sort()` уже выполнил и отсортировал список `l`. Таким образом, `.sort()` работает **"на месте"**

- При применении функции `sorted()` мы не меняем изначальные данные. Как же мы тогда получаем отсортированный массив? Как раз с помощью возвращаемого значения!
```Python
l = [3,1,5,4,2]

# Применяем функцию sorted() и сохраняем результат её работы
result = sorted(l)

print(l, result)
# [3,1,5,4,2] [1,2,3,4,5]
```

Мы видим неизменный изначальный массив и новый возвращённый массив, в котором лежит результат работы функции

Так как в работе с данными многие действия появляются в процессе экспериментов, хочется оставлять за собой возможность отменить действие и вернуться к предыдущему шагу. Поэтому зачастую методы, которые мы будем использовать, будут работать "не на месте". Будьте внимательны, поскольку для таких методов обязательно требуется создать новую переменную, в которую будет положен результат, или положить результат в ту же переменную, где лежал изначальный массив. Без этого результат будет безвозвратно утерян!

```Python
l = [3,1,5,4,2]

sorted(l)

print(l)
# [3,1,5,4,2]
```
Здесь мы применили функцию `sorted()`, работающую "не на месте" и не сохранили результат. В итоге он оказался утерян, изначальный список не поменялся и функция отработала напрасно
### Индексация

Мы научились создавать массив данных, определять его размер и тип данных, и теперь, как и в любой другой коллекции, важно научиться индексироваться по конкретным объектам. К счастью Numpy предоставляет для этого очень удобный функционал

Представим, что в качестве данных нам сообщили двумерную таблицу 3x3, состоящую из чисел от 1 до 9:

```Python
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]
```

Как и в стандартных списках, в np.array работает обычный выбор элемента по индексу. Возьмём элемент массива с индексом 1. Так как элементами нашего массива являются массивы строк таблицы, выберется соответствующая строка:

```Python
arr[1]
# [4 5 6]
```

Как ты видишь, всё работает так же, как и в стандартных коллекциях Python. А теперь давай возьмём из этой строки последний элемент (индекс 2). Сделать это можно по-привычному с помощью нескольких индексаций подряд:

```Python
# Последний элемент строки с индексом 1
arr[1][2]
# 6
```

Однако в Numpy существует и другой, более лаконичный способ задать вложенную индексацию. Для этого можно перечислить все индексы в рамках одних квадратных скобок один за другим через запятую:

```Python
arr[1, 2]
# 6
```

Такого стандартные списки Python нам предложить уже не могут. Этот способ выглядит лаконичнее и является более принятым при работе с Numpy
##### Срезы

Также в качестве индекса работают и срезы. Возьмём строки, начиная с первой (индекс 0) через одну с помощью среза:

```Python
arr[0::2]
# [[1 2 3] 
#  [7 8 9]]
```

Теперь попробуем взять все столбцы у этих строк, кроме самого первого. Для этого аналогично примеру выше можно использовать запись индексов через запятую:

```Python
# Строки, начиная с нулевой с шагом в 2 
# и столбцы, начиная с первого
arr[0::2, 1:]
# [[2 3] 
#  [8 9]]
```

Заметь, что стандартный способ с несколькими индексациями тут уже не сработает, так как вторая индексация будет рассматривать как объекты отобранные первой индексацией строки, и просто ещё раз профильтрует эти строки

```Python
# Строки, начиная с нулевой с шагом в 2, 
# И СРЕДИ НИХ строки, начиная с первой
arr[0::2][1:]
# [[7 8 9]]
```
### Арифметика

Чтобы производить подсчёты над данными, необходимо уметь применять арифметические операции к нашим массивам. Начнём с простейшего — суммы. 

В Numpy можно прибавлять к массиву число — в таком случае оно прибавится ко всем элементам массива. Возьмём массив `arr1` из предыдушей главы и добавим ко всем его элементам 10

```Python
arr1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]

arr1 + 10
# [[11 12 13] 
#  [14 15 16] 
#  [17 18 19]]
```


Также ты можешь складывать массивы одинаковых размеров друг с другом — в таком случае сложение произойдёт поэлементно. Возьмём массив `arr1` из предыдушей главы и добавим к нему массив из единиц той же формы, что и `arr1` — это можно сделать используя уже знакомое нам поле `shape` и функцию `np.ones()`:

```Python
arr1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]

# Массив из целых единиц размером 3x3
arr2 = np.ones(arr1.shape, , dtype=np.int64)
# [[1 1 1] 
#  [1 1 1] 
#  [1 1 1]]

# Сложим два массива
arr1 + arr2
# [[2 3 4] 
#  [5 6 7] 
#  [8 9 10]]
```

>[!note] Приведение размеров
>На следующем занятии мы увидим, что Numpy позволяет проводить операции и с массивами разных размеров, если однозначно понятно правило, по которому один массив можно привести к размерам другого. 
>
>Это приведение размеров (broadcasting) позволяет в том числе складывать массивы разных размеров, поэтому изучение этой особенности является важной темой следующего занятия

Разумеется, тот же принцип относится и к вычитанию:

```Python
arr1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]

# Массив из целых единиц размером 3x3
arr2 = np.ones(arr1.shape, , dtype=np.int64)
# [[1 1 1] 
#  [1 1 1] 
#  [1 1 1]]

# Вычтем из каждого элемента 10
arr1 - 10
# [[-9 -8 -7] 
#  [-6 -5 -4] 
#  [-3 -2 -1]]

# Вычтем один массив из другого
arr1 - arr2
# [[0 1 2] 
#  [3 4 5] 
#  [6 7 8]]
```

- - -

Аналогично работает произведение массива на число:

```Python
arr1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]

arr1 * 10
# [[10 20 30] 
#  [40 50 60] 
#  [70 80 90]]
```

И массива на массив. Умножим все элементы массива `arr1` на 2 поэлементно, используя массив того же размера, состоящий из двоек (для этого можно умножить на 2 массив ones)

```Python
arr1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]

# Массив из целых двоек размером 3x3
arr2 = np.ones(arr1.shape, dtype=np.int64) * 2
# [[2 2 2] 
#  [2 2 2] 
#  [2 2 2]]

arr1 * arr2
# [[2  4  6] 
#  [8  10 12] 
#  [14 16 20]]
```

Деление тоже работает предсказуемо, однако следует помнить, что как и в стандартном Python результат деления двух чисел (даже если это целые числа, нацело делящиеся друг на друга) будет дробным числом. Поделим наш массив `arr1` на 2 с помощью деления на число, а затем поэлементно поделим на 1, чтобы убедиться, что в результате получится дробное число

```Python
arr1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]

# Массив из целых единиц размером 3x3
arr2 = np.ones(arr1.shape, dtype=np.int64)
# [[1 1 1] 
#  [1 1 1] 
#  [1 1 1]]

arr1 / 2
# [[0.5 1. 1.5] 
#  [2. 2.5 3. ] 
#  [3.5 4. 4.5]]

# Даже при делении на 1 получаем дробный результат
arr1 / arr2
# [[1. 2. 3.] 
#  [4. 5. 6.]
#  [7. 8. 9.]]

print((arr1 / arr2).dtype)
# float64
```

- - - 

Для возведения в степень можно использовать `**` из стандартного синтаксиса Python или функцию `np.power()`, принимающую на вход массив и необходимую степень

```Python
arr1 ** 2
# [[ 1 4 9] 
#  [16 25 36]
#  [49 64 81]]

# То же, что arr1 ** 2
np.power(arr1, 2)
# [[ 1 4 9] 
#  [16 25 36]
#  [49 64 81]]
```

Для взятия корня можно использовать свойства степеней ($\sqrt{arr} = arr^{0.5}$ = `arr ** 0.5`) или напрямую воспользоваться функцией `np.sqrt()`

```Python
arr1 ** 0.5
# [[1. 1.41421356 1.73205081]
#  [2. 2.23606798 2.44948974]
#  [2.64575131 2.82842712 3. ]]

# То же, что arr ** 0.5
np.sqrt(arr1)
# [[1. 1.41421356 1.73205081]
#  [2. 2.23606798 2.44948974]
#  [2.64575131 2.82842712 3. ]]
```

Для некоторых формул в высшей математике требуется рассматривать числа в массиве как степени числа $e$, то есть для каждого числа $x$ из массива делать преобразование $x \rightarrow e^x$. Это возможно сделать с помощью функции `np.exp()`

```Python
arr1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]

np.exp(arr1)
# [[2.71828183e+00 7.38905610e+00 2.00855369e+01]
#  [5.45981500e+01 1.48413159e+02 4.03428793e+02]
#  [1.09663316e+03 2.98095799e+03 8.10308393e+03]]
```

##### Округление

Вернёмся к массиву из начала лонгрида, состоящему из чисел $\pi$ и $e$.
```Python
arr = np.array([np.pi, np.e])
# [3.14159265 2.71828183]
```

В ходе работы с этим массивом мы уменьшали точность вычислений, чтобы также уменьшить занимаемым массивом объем памяти, однако такой метод уменьшает числа до непредсказуемого размера. В примере ниже описание одного из чисел сократилось до двух знаков после запятой, а другого до трёх

```Python
arr.astype(np.float16)
# [3.14 2.719]
```

Чтобы лучше контролировать точность округления используют специализированную функцию `np.round()`, принимающую на вход массив и необходимое количество знаков после запятой:

```Python
np.round(arr, 0)
# [3. 3.]

np.round(arr, 1)
# [3.1 2.7]

np.round(arr, 2)
# [3.14 2.72]

np.round(arr, 6)
# [3.141593 2.718282]
```

При этом округление происходит следующим образом — если округляемся часть больше половины последнего разряда до округления, он увеличивается на единицу

```Python
arr = np.array([1.44, 1.45, 1.451])

np.round(arr, 1)
# [1.4, 1.4, 1.5]
```

В примере выше 1.45 округлилось до 1.4, так как округляемая часть в точности равна половине разрядка десятков. При этом 1.451 округлилось 1.5, так как в этом случае округляемая часть оказалось больше половины
##### Уникальные элементы

Давай вспомним стандартный Python и работу с его коллекциями. Если у нас есть список значений `l`, у которого мы хотим узнать все уникальные значения, мы можем преобразовать его к типу множества (`set`), в котором будут содержаться объекты списка без повторения

```Python
l = [1,1,2,2,2,3,4,5]

set(l)
# {1, 2, 3, 4, 5}
```

Эта операция нередко пригождается для реализации различных алгоритмов и анализа значений, и конечно же она не могла обойти стороной Numpy — для получения уникальных значений массива `np.array` используется функция `np.unique()`, возвращающая массив уникальных значений

```Python
arr = np.array([1,1,2,2,2,3,4,5])

np.unique(arr)
# [1 2 3 4 5]
```

TODO я бы всё-таки дал это на второй неделе

### Оси

Размерности массива, которые выше мы называли "измерениями" в Numpy имеют отдельное название — **оси** (axis). Так, у массива размером 3x1x4 есть три оси размеров 3, 1 и 4 соответственно. Ряд операций над массивами поддерживает работу с осями, и потому нам важно разобраться в них заранее.

Оси имеют порядковые номера и индексируются с нуля. В случае двумерного массива нулевой осью будет первый уровень вложенности (столбцы), а первой осью следующий за ним уровень вложенности (значения в строках). Убедимся в этом с помощью метода подсчёта суммы `np.sum()`, который мы разберём ниже. Помимо массива эта функция принимает на вход параметр `axis`, который задаёт направление суммирования

По умолчанию `axis=None` и с точки зрения подсчёта суммы наш массив является одномерным (просто считается сумма всех элементов)

```Python
arr = np.array([[1,2,3], [4,5,6]])
# [[1 2 3]
#  [4 5 6]] 

# 1 + 2 + 3 + 4 + 5 + 6 = 21
np.sum(arr)
# 21
```

Если мы укажем `axis=0`, суммирование произойдёт по самому внешнему уровню вложенности, то есть по тому уровню, где элементами являются строки. В этом случае суммирование будет происходить между соответствующими элементами этих строк:

```Python
arr = np.array([[1,2,3], [4,5,6]])
# [[1 2 3]
#  [4 5 6]] 

# 1 + 4 = 5
# 2 + 5 = 7
# 3 + 6 = 9
np.sum(arr, axis=0)
# [5 7 9]
```

Видим, что суммирование произошло по столбцам — указанная нами ось как бы "схлопнулась" под действием аггрегации, оставив только другую измерение — ось строк. Аналогично при `axis=1` суммирование "схлопнет" уже ось строк, оставив размерность столбцов

```Python
arr = np.array([[1,2,3], [4,5,6]])
# [[1 2 3]
#  [4 5 6]] 

# 1 + 2 + 3 = 6
# 4 + 5 + 6 = 15
np.sum(arr, axis=1)
# [6 15]
```

В дальнейшем ты познакомишься с большим количеством функций, поддерживающих параметр `axis`. По сути любая аггрегация, то есть вычисление одного числа на основе массива, также поддерживает вычисление аггрегируемого значения вдоль любой из осей. 

Ниже добавлен пример трёхмерного массива размера 3x4x2 и аггрегация суммы над ним. Чтобы окончательно разобраться с осями в Numpy постарайся посчитать результат суммы для разных осей самостоятельно, не заглядывая в ответ. Если ты затрудняешься ответить вспомни, какая из осей должна "схлопнуться" и массив какой формы в таком случае должен получиться

```Python
arr = np.array([[[1,2], [3,4], [5,6], [7,8]],
				[[2,3], [4,5], [6,7], [8,9]],
				[[3,4], [5,6], [7,8], [9,10]]])

# a)
np.sum(arr, axis=0)
# ?

# б)
np.sum(arr, axis=1)
# ?

# в)
np.sum(arr, axis=2)
# ?

# Ответ

# a)
# [[ 6 9] 
#  [12 15]
#  [18 21]
#  [24 27]]

# б)
# [[16 20] 
#  [20 24]
#  [24 28]]

# в)
# [[ 3 7 11 15] 
#  [ 5 9 13 17]
#  [ 7 11 15 19]]
```
### Изменение формы

Как вы могли заметить, для ряда операций важно, чтобы у массивов чисел были совместимые формы. В случае, если по какой-то причине (а такие причины на практике возникают довольно часто) нам понадобится поменять размеры нашего массива, следует воспользоваться методом `reshape()`, получающим на вход форму желаемого массива. Как вы уже догадались, принимается она в том числе в формате кортежа. 

Давайте применим метод reshape к массиву из прошлой главы. Представим числа от 1 до 9 как обычную одномерную последовательность размера 9, а не как двумерную таблицу размера 3x3

```Python
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]

print(arr.shape)
# (3, 3)

new_arr = arr.reshape((9))

print(new_arr)
# [1 2 3 4 5 6 7 8 9]

print(new_arr.shape)
# (9)
```

У нас получилось поменять размер массива, оставив на месте все значения и сохранив их порядок! Метод `reshape()` работает не на месте, поэтому при его вызове мы создаём новую переменную `new_arr`.

Метод `reshape` имеет очевидные ограничения — перевести массив размера (3x3) к размеру (100x50x10), к сожалению, не выйдет, так как общее количество элементов у этих массивов разное

```Python
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]

new_arr = arr.reshape((100, 50, 10))
# ValueError
```

Кажется, что из-за этого ограничения нам каждый раз придётся подсчитывать количество элементов вдоль каждой из осей и следить, чтобы это количество оставалось неизменным. Делать это настолько дотошно для массивов с большим количеством осей не хочется, поэтому в методе `reshape` есть одно очень удобное послабление

Если у вас имеется массив из 100 элементов, и в методе reshape вы указали, что всего вы хотите получить 3 оси, а первые 2 оси имеют размер 5 и 5, мы можем однозначно подсчитать размер последней оси ($5 \cdot 5 \cdot x = 100$).

Иногда нам бывает важно задать только часть размера массива, а в оставшуюся размерность поместить "всё остальное". Для этого в `reshape` на месте этой оси следует написать `-1` — увидев это значение в качестве размера одной из оси Numpy автоматически посчитает нужное значение

```Python
arr = np.zeros((100))

# Не указываем последнюю ось
# Оставляем это на подсчёт Numpy
new_arr = arr.reshape((5, 5, -1))

new_arr.shape
# (5, 5, 4)
```

Действительно, массив размера 5x5x4 содержит 100 элементов, как и было в изначальном массиве!

Автоматический подсчёт размера одной из осей очень удобен. Например, он позволяет легко "выпрямить" любой массив в одномерную последовательность:

```Python
# Многомерный массив. Как его можно "выпрямить?"
arr = np.zeros((3,5,1,4,10,7,3))

new_arr = arr.reshape((-1))

# Оказалось, в этом массиве 12600 элементов
# Numpy посчитал это за нас
new_arr.shape
# 12600
```

К слову, подобное "выпрямление" многомерного массива в одну ось возможно и отдельным методом. Так как одномерные массивы выглядит как "плоские", однострочные последовательности, такие массивы так и называют — flat (плоские), а метод приведения к плоскому массиву — `flatten`

```Python
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]

new_arr = arr.flatten()
# [1 2 3 4 5 6 7 8 9]
```

Вернёмся к значению -1, позволяющему автоматически выбрать необходимый размер оси: у такого автоматического подсчёта тоже есть свои ограничения. Например, не всегда существует **целый** размер оси, попадающий под условия (5 элементов нельзя перевести в таблицу с 3 строками). Чтобы этого избежать, следует задавать размеры так, чтобы общее количество элементов быть кратно произведению всех остальных значений, указанных явно

```Python
arr = np.zeros((100))

# Работает без ошибок, т.к. 100 делится на 5*5=25
# Оставшийся размер равен 100 / 25 = 4
new_arr = arr.reshape(5, -1, 5)

# Выдаст ошибку, т.к. 100 не делится на 3*17=51
new_arr = arr.reshape(3, -1, 17)
# ValueError
```

Также нельзя указывать более одной -1, так как почти всегда это приводит к неоднозначности подсчёта

```Python
arr = np.zeros((100))

# Выдаст ошибку, т.к. существует несколько способ подсчёта размеров
# 10 * 10 * 1 = 100
# 10 * 5  * 2 = 100
# 10 * 2  * 5 = 100
# 10 * 1 * 10 = 100
new_arr = arr.reshape(10, -1, -1)
# ValueError
```

Однако даже несмотря на все эти ограничения, автоматический подсчёт размера массива — очень полезная и активно применяющаяся на практике функция, которая не раз поможет тебе в ходе экспериментов

##### Транспонирование

Ещё одной полезной операцией при работе с массивами является транспонирование — переворот массива, меняющий местами две оси. В случае двумерных таблиц это означает перевод строк в столбцы, а столбцов в строки. Делается это с помощью метода `transpose` (работает не на месте) или сокращения `T` — оно взято из линейной алгебры, где операция транспонирования является одной из основных:

```Python
arr1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]

# Столбцы и строки поменялись местами
arr2 = arr1.transpose()
# [[1 4 7] 
#  [2 5 8]
#  [3 6 9]]

# Вместо вызова метода transpose можно взять атрибут T
arr3 = arr1.T
# [[1 4 7] 
#  [2 5 8]
#  [3 6 9]]

```
### Статистики

Из названия курса понятно, что библиотека Numpy нас не в последнюю очередь интересует с точки зрения статистического анализа, поэтому в этой главе давайте разберемся с основными значениями в статистике и тем, как с ними работать в Numpy
##### Распределение

Статистика работает с данными, подчиняющимися определённым законам и чья случайность описывается определёнными правилами. Эти правила, описывающие случайность, называются **распределением**. Так, результат броска кубика подчиняется равномерному распределению (все результаты равновероятны), а количество орлов при пятикратном подбрасывании монеты биномиальному распределению (пять орлов гораздо менее вероятны, чем три орла). 

О видах распределений и их более строгом определении мы поговорим позже. Сейчас важно понимать, что распределение — это идеальное математическое правило, описывающее характер случайности
##### Выборка

Любая практическая задача это прежде всего работа с конкретными данными, а не с идеальной математической моделью случайности. Такой набор данных называется **выборкой** — это конкретные числа, которые, как мы предполагаем, были получены из некоторого идеального математического распределения

Важно понимать, что вид идеального математического распределения и вид конкретной выборки могут отличаться. Так, идеальное равномерное распределение предполагает, что вероятность выпадания на кости единицы такая же, как вероятность выпадания шестёрки, однако в конкретной полученной выборке может оказаться сто единиц и не оказаться ни одной шестёрки
##### Статистика

И модельные математические распределения, и полученные на практике выборки нужны, чтобы производить нам ними подсчёты. Нередко оказывается удобно саггрегировать сложный закон случайности в одно лаконичное число. Такое число, полученное на основе распределения случайности называется как и наука — **статистикой**. 

Статистики считают как на основе распределений, так и на основе конкретных выборок. Во втором случае их называют **выборочными** и подразумевают, что статистика основана на конкретных числах и не обязательно точно показывает характеристику математического распределения. 

В ходе ближайший занятий мы будем заниматься исключительно выборочными статистиками и оставим подсчёт настоящих статистик на потом. Начнём изучение статистик с, пожалуй, самого популярного и информативного числа для всей выборки — среднего
##### Выборочное среднее

Среднее — это статистика, которая не нуждается в представлении. Для выборки $x_1, x_2, \dots, x_n$ выборочное среднее вычисляется как
$$mean = \frac{x_1+x_2+\dots+x_n}{n}$$
Выборочное среднее говорит о центре тяжести выборки, том значении, которое ближе всего находится ко всем данным выборки. Среднее является полезным числом для любой выборки, однако в её использовании стоит быть аккуратным — одна из проблем выборочного среднего в том, что оно чувствительно к **выбросам**, то есть данным, сильно выбивающимся из общей тенденции

Например, выборки $[1,3,2,3,1]$ и $[2,3,2,3,1000]$ похожи по своему характеру, не считая очевидный выброс в виде числа 1000. Такой выброс мог появиться случайно, например из-за ошибки при переносе данных в компьютер. При этом среднее первой выборки равняется
$$mean_1 = \frac{1 + 3 + 2 + 3 + 1}{5} = 2$$
А среднее второй выборки оказывается на порядок больше
$$mean_2=\frac{2+3+2+3+1000}{5} = 202$$
Поэтому при подсчёте среднего важно заранее убрать все выбросы, чтобы среднее не было смещено. О том, как вычислять выбросы, мы поговорим на пятом занятии

- - -

В Numpy для подсчёта выборочного среднего используется функция `np.mean()` (от английского mean — среднее), принимающая на вход массив

```Python
arr1 = np.array([[1, 2], [3, 4]])
# [[1 2]
#  [3 4]]

# (1 + 2 + 3 + 4) / 4 = 2.5
print(np.mean(arr1))
# 2.5
```

Также `np.mean()`, как и остальные агрегации, можно подсчитывать вдоль осей, указав необязательный параметр `axis`

```Python
arr1 = np.array([[1, 2], [3, 4]])
# [[1 2]
#  [3 4]]

# (1 + 3) / 2 = 2
# (2 + 4) / 2 = 3
np.mean(arr1, axis=0)
# [2. 3.]

# (1 + 2) / 2 = 1.5
# (3 + 4) / 2 = 3.5
np.mean(arr1, axis=1)
# [1.5 3.5]
```

##### Выборочная медиана

Представь, что тебе дали информацию о зарплатах людей в какой-то стране, и ты хочешь понять общий "масштаб" этих зарплат. Как мы выяснили, выборочное среднее является не лучшим выбором, потому что оно может сильно поменяться при наличии выбросов (например, несколько очень богатых людей сместят информацию о среднем). Вместо этого в голову может прийти идея посмотреть на зарплату "среднего" человека, отсортировав всех по зарплатам и взяв число из середины. Именно этим и является выборочная медиана. 

Разберёмся с тем, как обозначать отсортированную выборку: при сортировке выборки $x_1, x_2, \dots , x_n$ значения поменяют свой порядок, и индексы будут идти в каком-то другом порядке $x_*, x_*, \dots, x_*$. Для отсортированной выборки номер первой по порядку величины принято обозначать в скобках — это указывает на упорядоченность объектов: $x_{(1)}, x_{(2)}, \dots, x_{(n)}$

Теперь мы готовы дать определение медианы — для упорядоченной выборки $x_{(1)}, x_{(2)}, \dots, x_{(n)}$ медиана, кажется, считается как
$$median = x_{(n/2)}$$

Однако внимательный читатель сразу задастся вопросом — как быть, если среднего элемента нет? Действительно, на самом деле для выборок с чётным и нечётным количеством элементов правила подсчёта медианы немного разные. Разберёмся подробнее.

Если выборка содержит нечётное количество элементов, среднее значение легко определяется (например для выборки $[1,3,7,8,10]$ это будет 7), но технически формула для подсчёта будет другой, ведь у выборки нечётного размера не существует элемента с индексом $\frac{n}{2}$. Вместо него нам подойдёт $\frac{n+1}{2}$ (если индексироваться с единицы)

Если же выборка содержит чётное количество элементов, возникает проблема — у неё нет среднего (например для выборки $[1,3,7,8]$ средними являются одновременно и 3 и 7). Можно было бы выбрать в качестве медианы левое среднее или правое среднее значение, но любое из этих решений было бы необоснованно, ведь среди этих чисел нет более "главного". Именно поэтому в случае с чётным размером выборки медиана считается как **среднее** двух средних чисел. Эти числа находятся под индексами $\frac{n}{2}$ и $\frac{n}{2} + 1$

Теперь мы можем дать полноценное определение медианы. Из-за описанных выше ньюансов определение разбивается на два разных случая:

$$median=\begin{cases}x_{(\frac{n+1}{2})}, \text{если}\;n\;\text{нечётно}\\ \frac{x_{(\frac{n}{2})} + x_{(\frac{n}{2} + 1)}}{2}, \text{если}\;n\;\text{чётно}\end{cases}$$

Медиана очень устойчива к выбросам, и в этом отношении лучше, чем среднее, однако она заостряет внимание на одном (максимум двух) объектах выборки, не давая никакой информации об остальных объектах, в то время как на среднее понемногу влияет каждый элемент выборки 

- - -

В Numpy для подсчёта выборочной медианы используется функция `np.median()`. Её также можно запустить вдоль конкретных осей с помощью аргумента `axis`:

```Python
arr1 = np.array([[1, 2, 3], [4, 5, 6]])
# [[1 2 3]
#  [4 5 6]]

# (3 + 4) / 2 = 3.5
np.median(arr1)
# 3.5

# (1 + 4) / 2 = 2.5
# (2 + 5) / 2 = 3.5
# (3 + 6) / 2 = 4.5
np.median(arr1, axis=0)
# [2.5 3.5 4.5]

np.median(arr1, axis=1)
# [2. 5.]
```

##### Выборочные минимум и максимум

Что может быть проще, чем просто найти наибольший и наименьший элемент в выборке? Действительно, выборочный максимум и выборочный минимум являются одними из самых простых в описании статистик. Для выборки $x_1, x_2, \dots, x_n$ выборочным максимумом будет
$$max = max(x_1, x_2, \dots, x_n) = x_{(n)}$$
А выборочным минимумом
$$min = min(x_1, x_2, \dots, x_n) = x_{(1)}$$
На практике иногда интересен в том числе **размах** выборки, то есть покрываемый ею диапазон значений:

$$range = max - min$$
- - -

В Numpy для максимума и минимума существуют функции `np.max()` и `np.min()`, поддерживающие работу с осями

```Python
arr1 = np.array([[1, 2, 3], [4, 5, 6]])
# [[1 2 3]
#  [4 5 6]]

print(np.min(arr1))
# 1

print(np.min(arr1, axis=0))
# 1 2 3

print(np.min(arr1, axis=1))
# 1 4

print(np.max(arr1))
# 6

print(np.max(arr1, axis=0))
# 4 5 6

print(np.max(arr1, axis=1))
# 3 6
```

##### Выборочная мода

Иногда полезно узнать, какое из значений встречается в выборке чаще всего. Эта статистика называется **модой**. К сожалению, записать аналитическую формулу для моды довольно трудно, поэтому ограничимся словесным определением

**Выборочная мода** — наиболее часто встречающееся значение в выборке

Мода может быть не единственной. Так, для выборки $[1,1,3,2,3,5]$ модой являются числа 1 и 3

- - -

TODO а как моду в numpy писать?...
##### Выборочная дисперсия

Разброс между минимумом и максимум помогает оценить то, о чём не говорили ни среднее, ни медиана — разрозненность значений. При этом даже разброс выборки может быть недостаточно информативен. Например обе выборки $[1,1,9,9]$ и $[1,5,5,9]$  имеют среднее 5, медиану 5 и разброс 8, однако во втором случае числа более кучно располагаются около центра

Давайте попробуем оценить эту отдалённость от центра на примере выборки $[1,2,4,5]$. Посчитаем среднее этой выборки
$$mean = \frac{1+2+4+5}{4} = 3$$
Нас интересует удалённость объектов от центра, поэтому вычислим разницу между каждым объектом и средним.
$$1-3 = -2$$
$$2-3 = -1$$
$$4-3 = 1$$
$$5-3 = 2$$
Видим, что какие-то разницы оказались отрицательными. Это не очень удобно для подсчёта, поэтому давайте преобразуем все разницы в неотрицательные, возведя их в квадрат:

$$(1-3)^2=4$$
$$(2-3)^2=1$$
$$(4-3)^2=1$$
$$(5-3)^2=4$$
Изначально имея на руках выборку $[1,2,4,5]$ мы получили новую четвёрку значений $[4,1,1,4]$, описывающую удалённость каждого из объектов от центра выборки. Эти значения можно усреднить. Получаемая таким образом статистика называется **выборочной дисперсией** (variance) и показывает среднее квадратичное отклонение элементов выборки от её центра
$$var = \frac{(x_1-mean)^2 + (x_2-mean)^2 + \dots + (x_n - mean) ^ 2}{n}$$
Дисперсия и среднее являются классической парой статистик, считаемых для каждой выборки. Одна показывает среднюю величину, вокруг которой расположены значения, в то время как другая показывает разброс этих значений

Однако и дисперсия не лишена недостатка. Дело в том, что по ходу вычисления выборочной дисперсии мы возводили в квадрат разницы чисел. Если в изначальной выборке значения исчислялись тысячами, квадраты разности могут исчисляться миллионами. Из-за этого изменения масштаба выборочную дисперсию сложнее интерпретировать. Так почему бы не посчитать корень из итогового значения? Такая статистика называется **стандартным отклонением**

$$std= \sqrt{var}$$
Масштаб выборочного стандартного отклонения уже сопоставим с объектами выборки

- - -

В Numpy выборочная дисперсия считается с помощью функции `np.var()`, поддерживающей работу с осям

```Python
arr = np.array([[1,2],[4,5]])
# [[1 2]
#  [4 5]]

np.var(arr)
# 2.5

np.var(arr, axis=0)
# [2.25 2.25]

np.var(arr, axis=1)
# [0.25 0.25]
```

Аналогично для стандартного отклонения используется `np.std()`

```Python
arr = np.array([[1,2],[4,5]])
# [[1 2]
#  [4 5]]

np.std(arr)
# 1.5811388300841898

np.std(arr, axis=0)
# [1.5 1.5]

np.std(arr, axis=1)
# [0.5 0.5]
```

##### Сумма и произведение

В конце этой главы давайте разберёмся, как вычислять произведение и сумму элементов массива. Для этого в Numpy существует две функции с говорящими названиями — `np.sum()` и `np.prod()`. Они также поддерживают работу с осями

```Python
arr = np.array([[1,2], [3,4]])
# [[1 2]
#  [3 4]]

np.prod(arr)
# 24

np.prod(arr, axis=0)
# [3 8]

np.prod(arr, axis=1)
# [2 12]

np.sum(arr)
# 10

np.sum(arr, axis=0)
# [4 6]

np.sum(arr, axis=1)
# [3 7]
```
### Заключение

Поздравляем, теперь ты владеешь базовым функционалом Numpy и способен использовать эту библиотеку для решения задач! Сегодня мы разобрали способы создания массивов, типы данных, индексацию, работу с арифметикой и изменение формы массивов. Помимо этого мы разобрали основные выборочные статистики, среди них — среднее, медиана, мода, дисперсия. 

Но самое интересное всё ещё впереди — на следующем занятии мы научимся применять фильтры и строить булевы маски, производить конкатенацию массивов, сортировать данные, а также разберём более продвинутые статистики. Все эти знания послужат крепким фундаментом для дальнешей работе на курсе

TODO навыки