
### TODO

Убрать np.empty() из недели 1, он не нужен
### Навыки

- [ ] arange
- [ ] random (rand, randn, randint)
- [ ] linspace

- [ ] Булева индексация
- [ ] where
- [ ] indices
- [ ] & |

- [ ] Броадкаст
- [ ] concatenate
- [ ] stack vstack hstack
- [ ] split  vsplit hsplit

- [ ] sort
- [ ] argsort

- [ ] unique

- [ ] nan inf
- [ ] isnan isinf

- [ ] квантиль квартиль перцентиль дециль

- [ ] save, load

### Введение

На прошлом занятии мы разобрались в основах работы с Numpy — важнейшей библиотеки для работы с данными. Теперь мы умеем создавать массивы, менять их форму и производить над ними базовые подсчёты, включающие разнообразные статистики — от среднего до дисперсии

Теперь пришло время закрепить наше понимание Numpy и допройти не менее важные темы. Как слкадывать массивы разного размера? Как разрезать массив на части и скреплять эти части воедино? Как фильтровать значения в массиве и что скрывается за загодчным словом "квантиль" — вот лишь часть вопросов, на которые ты сегодня получишь ответ
### Случайные массивы и прогрессии

На прошлом занятии мы выяснили, что массивы в Numpy создаются с помощью команд np.ones(), np.zeros(), np.empty(), однако создавать массивы можно множеством других способов! Давай разберём еще два вида создаваемых массивов — массив со случайными значениями и массив, повторяющий работу range.

FMT Пример
Представь, что тебе нужно провести статистический эксперимент, для которого необходимо 1000 раз бросить игральный кубик или просимулировать действие, которое происходит с определённой вероятностью. Для всего этого нужно генерировать случайные числа. 

Благодаря Numpy мы можем генерировать целые массивы случайных чисел, причём как дробных, так и целочисленных!
##### Дробные случайные числа

Для генерации случайных чисел в numpy существует модуль numpy.random, содрежащий все необходимые функции. Простейший способ генерации — запустить функцию np.random.rand(). Она вернёт случайное число в диапазоне [0, 1]. Запустим эту функцию три раза и посмотрим на результат

```Python
np.random.rand()
# 0.22956426320097922

np.random.rand()
# 0.5604792255910517

np.random.rand()
# 0.9560841356049328
```

Мы действительно получаем случайные значения, однако это всего лишь одно число, хотя чуть выше мы говорили про огромные массивы из случайных чисел! Не будем же мы каждый раз генерировать эти числа по одному? Для того, чтобы сразу сгенерировать множество случайных чисел необходимо просто указать их количество аргументом функии np.random.rand(). Давай сгенерируем сразу 5 случайных чисел!

```Python
np.random.rand(10)
# [0.02835481 0.91979138 0.54497486 0.7651125 0.72090305]
```

Теперь мы получаем массив случайных чисел, причём из-за того, что все они лежат в диапазоне [0, 1], с ними можно работать в контексте вероятностей, что может быть крайне удобно

FMT Пример
Условие
У тебя есть нечестная решка, выпадающая орлом вверх с 70% вероятностью, а решкей вверх лишь с 30% вероятностью. Просимулируй десятикратное подбрасывание такой монеты и скажи, сколько выпало решек

Решение
Так как мы умеем генерировать случайные числа в диапазоне [0,1], давайте используем их для симуляции подбрасывания. Если мы договоримся, что значения меньшие чем 0.7 символизирует выпадение орла, а больше или равные 0.7 выпадание решки, мы получим честную ситуацию, потому что 7/10 области генерации будет отдано под выпадание орла, а значит это событие будет происходить с вероятностью 70%! 

Так мы перешли от генерации случайного числа до симуляции события, происходящего с определённой вероятностью. Сгенерируем 10 случайных чисел
```Python
np.random.rand(10)
# [0.83483757, 0.66405171, 0.62089576, 0.46204415, 0.74101565, 0.07412343 , 0.89601135, 0.95090495, 0.20084881, 0.65094529]
```

Проанализируем результат:
- 0.83483757 > 0.7 => Выпала решка
- 0.66405171 < 0.7 => Выпал орёл
- 0.62089576 < 0.7 => Выпал орёл
- 0.46204415 < 0.7 => Выпал орёл
- 0.74101565 > 0.7 => Выпала решка
- 0.07412343 < 0.7 => Выпал орёл
- 0.89601135 > 0.7 => Выпала решка
- 0.95090495 > 0.7 => Выпала решка
- 0.20084881 < 0.7 => Выпал орёл
- 0.65094529 < 0.7 => Выпал орёл

Итого в нашем случае выпало **4 решки**. Разумеется, из-за случайности сгенерированных чисел из запуска в запуска они, а значит и итоговое количество решек, могут отличаться

FMT  ibox
Заметь, что уже при десяти значениях заниматься ручной обработкой данных становится довольно неудобно. Не волнуйся — в следующей главе мы разберём способ автоматической обработки и фильтрации чисел, которые позволят получать ответ на подобные задачи автоматически (а значит мы сможем подбрасывать монету не 10, а 10000 раз!)

Генерация чисел в диапазоне [0,1] довольно удобна, однако 


Поменять диапазон?

##### Целые случайные числа


FMT ibox
Ядро генерации

##### У нас есть range дома (TODO не повторяюсь?)

Также можно сходу создавать одномерные массивы, содержащие внутри себя арифметическую прогрессию как при написании `range`. Это делается с помощью метода `np.arange()` с привычными аргументами начала, конца и шага.

```Python
arr = np.arange(4)
# [0 1 2 3]

arr = np.arange(1, 10)
# [1 2 3 4 5 6 7 8 9]

arr = np.arange(1, 10, 2)
# [1 3 5 7 9]
```

### Булевы маски и логические выражения

### Работа с несколькими массивами

### Сортировка

### Бесконечность — не предел

### Статистики


### Сохранение и загрузка

Ты научился многим операциям с массивами в Numpy, однако пока едва ли способен решить какую-то реальную задачу, потому что массивы данных  нужно откуда-то получать, а результаты работы куда-то сохранять. К счастью, и это в Numpy делается легко и в одну команду. Cохранить массив можно командой `np.save()` передав туда имя файла и сохраняемый массив. Сохранение происходит в специальном формате `npy`, созданного для хранения Numpy массивов.

```Python
arr = np.array([1,2,3,4,5])

np.save("file_with_array.npy", arr)
```

После применения этой функции в директории исполняемого кода появится файл `file_with_array.npy`.

Открытие файла и его запись в массив происходит с помощью функции `np.load()`, которая получает на вход название файла:

```Python
arr = np.load("file_with_array.npy")
# [1 2 3 4 5]
```

### Заключение

Сегодня ты разобрал большое количество тем, которые закрывают потребности в использовании Numpy для подавляющего большинства сценариев. На этом мы заканчиваем изучение этой мощнейшей библиотеки для работы с данными и уже на следующем занятии разберём следующий, не менее важный инструмент, который является одним из стандартов для работы с таблицами — Pandas