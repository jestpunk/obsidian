### Навыки

- [ ] arange
- [ ] random (rand, randn, randint)
- [ ] linspace

- [ ] Булева индексация
- [ ] where
- [ ] indices
- [ ] & |

- [ ] Броадкаст
- [ ] concatenate
- [ ] stack vstack hstack
- [ ] split  vsplit hsplit

- [ ] sort
- [ ] argsort

- [ ] unique

- [ ] nan inf
- [ ] isnan isinf

- [ ] квантиль квартиль перцентиль дециль

- [ ] save, load

### Введение

На прошлом занятии мы разобрались в основах работы с Numpy — важнейшей библиотеки для работы с данными. Теперь мы умеем создавать массивы, менять их форму и производить над ними базовые подсчёты, включающие разнообразные статистики — от среднего до дисперсии

Теперь пришло время закрепить наше понимание Numpy и допройти не менее важные темы. Как слкадывать массивы разного размера? Как разрезать массив на части и скреплять эти части воедино? Как фильтровать значения в массиве и что скрывается за загодчным словом "квантиль" — вот лишь часть вопросов, на которые ты сегодня получишь ответ
### Случайные массивы и прогрессии

На прошлом занятии мы выяснили, что массивы в Numpy создаются с помощью команд np.ones(), np.zeros(), np.empty(), однако создавать массивы можно множеством других способов! Давай разберём еще два вида создаваемых массивов — массив со случайными значениями и массив, повторяющий работу range

##### Генерация случайных чисел



##### У нас есть range дома

Также можно сходу создавать одномерные массивы, содержащие внутри себя арифметическую прогрессию как при написании `range`. Это делается с помощью метода `np.arange()` с привычными аргументами начала, конца и шага. 

```Python
arr = np.arange(4)
# [0 1 2 3]

arr = np.arange(1, 10)
# [1 2 3 4 5 6 7 8 9]

arr = np.arange(1, 10, 2)
# [1 3 5 7 9]
```

### Булевы маски и логические выражения

### Работа с несколькими массивами

### Сортировка

### Бесконечность — не предел

### Статистики


### Сохранение и загрузка

Ты научился многим операциям с массивами в Numpy, однако пока едва ли способен решить какую-то реальную задачу, потому что массивы данных  нужно откуда-то получать, а результаты работы куда-то сохранять. К счастью, и это в Numpy делается легко и в одну команду. Cохранить массив можно командой `np.save()` передав туда имя файла и сохраняемый массив. Сохранение происходит в специальном формате `npy`, созданного для хранения Numpy массивов.

```Python
arr = np.array([1,2,3,4,5])

np.save("file_with_array.npy", arr)
```

После применения этой функции в директории исполняемого кода появится файл `file_with_array.npy`.

Открытие файла и его запись в массив происходит с помощью функции `np.load()`, которая получает на вход название файла:

```Python
arr = np.load("file_with_array.npy")
# [1 2 3 4 5]
```

### Заключение

Сегодня ты разобрал большое количество тем, которые закрывают потребности в использовании Numpy для подавляющего большинства сценариев. На этом мы заканчиваем изучение этой мощнейшей библиотеки для работы с данными и уже на следующем занятии разберём следующий, не менее важный инструмент, который является одним из стандартов для работы с таблицами — Pandas