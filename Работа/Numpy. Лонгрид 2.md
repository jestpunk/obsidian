
### TODO

- Определения по стате с текстовым пояснениями
- Переписать семинары / ДЗ
- Добавить сюда абсолютную и относительную частот

Убрать np.empty() из недели 1, он не нужен
### Навыки

- [ ] arange
- [ ] random (rand, randn, randint)
- [ ] linspace

- [ ] Булева индексация
- [ ] where
- [ ] indices
- [ ] & |

- [ ] Броадкаст
- [ ] concatenate
- [ ] stack vstack hstack
- [ ] split  vsplit hsplit

- [ ] sort
- [ ] argsort

- [ ] unique

- [ ] nan inf
- [ ] isnan isinf

- [ ] квантиль квартиль перцентиль дециль

- [ ] save, load

### Введение

На прошлом занятии мы разобрались в основах работы с Numpy — важнейшей библиотеки для работы с данными. Теперь мы умеем создавать массивы, менять их форму и производить над ними базовые подсчёты, включающие разнообразные статистики — от среднего до дисперсии

Теперь пришло время закрепить наше понимание Numpy и допройти не менее важные темы. Как слкадывать массивы разного размера? Как разрезать массив на части и скреплять эти части воедино? Как фильтровать значения в массиве и что скрывается за загодчным словом "квантиль" — вот лишь часть вопросов, на которые ты сегодня получишь ответ
### Случайные массивы и прогрессии

На прошлом занятии мы выяснили, что массивы в Numpy создаются с помощью команд np.ones(), np.zeros(), np.empty(), однако создавать массивы можно множеством других способов! Давай разберём еще два вида создаваемых массивов — массив со случайными значениями и массив, повторяющий работу range.

FMT Пример
Представь, что тебе нужно провести статистический эксперимент, для которого необходимо 1000 раз бросить игральный кубик или просимулировать действие, которое происходит с определённой вероятностью. Для всего этого нужно генерировать случайные числа. 

Благодаря Numpy мы можем генерировать целые массивы случайных чисел, причём как дробных, так и целочисленных!
##### Дробные случайные числа

TODO посмотреть на другие аргументы функции

Для генерации случайных чисел в numpy существует модуль numpy.random, содрежащий все необходимые функции. Простейший способ генерации — запустить функцию np.random.rand(). Она вернёт случайное число в диапазоне [0, 1]. Запустим эту функцию три раза и посмотрим на результат

```Python
np.random.rand()
# 0.22956426320097922

np.random.rand()
# 0.5604792255910517

np.random.rand()
# 0.9560841356049328
```

Мы действительно получаем случайные значения, однако это всего лишь одно число, хотя чуть выше мы говорили про огромные массивы из случайных чисел! Не будем же мы каждый раз генерировать эти числа по одному? Для того, чтобы сразу сгенерировать множество случайных чисел необходимо просто указать их количество аргументом функии np.random.rand(). Давай сгенерируем сразу 5 случайных чисел!

```Python
np.random.rand(10)
# [0.02835481 0.91979138 0.54497486 0.7651125 0.72090305]
```

Теперь мы получаем массив случайных чисел, причём из-за того, что все они лежат в диапазоне [0, 1], с ними можно работать в контексте вероятностей, что может быть крайне удобно

FMT Пример
Условие
У тебя есть нечестная решка, выпадающая орлом вверх с 70% вероятностью, а решкей вверх лишь с 30% вероятностью. Просимулируй десятикратное подбрасывание такой монеты и скажи, сколько выпало решек

Решение
Так как мы умеем генерировать случайные числа в диапазоне [0,1], давайте используем их для симуляции подбрасывания. Если мы договоримся, что значения меньшие чем 0.7 символизирует выпадение орла, а больше или равные 0.7 выпадание решки, мы получим честную ситуацию, потому что 7/10 области генерации будет отдано под выпадание орла, а значит это событие будет происходить с вероятностью 70%! 

Так мы перешли от генерации случайного числа до симуляции события, происходящего с определённой вероятностью. Сгенерируем 10 случайных чисел
```Python
np.random.rand(10)
# [0.83483757, 0.66405171, 0.62089576, 0.46204415, 0.74101565, 0.07412343 , 0.89601135, 0.95090495, 0.20084881, 0.65094529]
```

Проанализируем результат:
- 0.83483757 > 0.7 => Выпала решка
- 0.66405171 < 0.7 => Выпал орёл
- 0.62089576 < 0.7 => Выпал орёл
- 0.46204415 < 0.7 => Выпал орёл
- 0.74101565 > 0.7 => Выпала решка
- 0.07412343 < 0.7 => Выпал орёл
- 0.89601135 > 0.7 => Выпала решка
- 0.95090495 > 0.7 => Выпала решка
- 0.20084881 < 0.7 => Выпал орёл
- 0.65094529 < 0.7 => Выпал орёл

Итого в нашем случае выпало **4 решки**. Разумеется, из-за случайности сгенерированных чисел из запуска в запуска они, а значит и итоговое количество решек, могут отличаться

FMT  ibox
Заметь, что уже при десяти значениях заниматься ручной обработкой данных становится довольно неудобно. Не волнуйся — в следующей главе мы разберём способ автоматической обработки и фильтрации чисел, которые позволят получать ответ на подобные задачи автоматически (а значит мы сможем подбрасывать монету не 10, а 10000 раз!)

- - - 

Генерация чисел в диапазоне [0,1] довольно удобна, однако что делать, если нам понадобился другой диапазон? На самом деле, ты уже способен сам ответить на этот вопрос

FMT Пример
Геймдизайнер Женя разрабатывает игру про футбол. Помоги Жене сгенерировать для виртуальной футбольной команды рост каждого из 11-ти виртуальных игроков. Договоримся, что рост игрока не может быть меньше 150см и больше 200см

Неправильное решение
Всё, что нам нужно для решения задачи — сгенерировать 11 чисел в диапазоне [150, 200], однако пока что мы умеем генерировать только числа в диапазоне [0,1]... Тем не менее, давай сгенерируем хотя бы их и сохраним в переменную arr

```Python
arr = np.random.rand(11)
# [0.54531202 0.15409312 0.03515661 0.83110824 0.14448973 0.56177461 0.03481867 0.02251258 0.51208935 0.52066764 0.73012772]
```

Давай попробуем подвинуть левую границу до 150. С прошлого занятия мы умеем прибавлять к значениям массива фиксированное число

```Python
arr_150 = arr + 150
# [150.54531202 150.15409312 150.03515661 150.83110824 150.14448973 150.56177461 150.03481867 150.02251258 150.51208935 150.52066764 150.73012772]
```

Часть задачи решена. Теперь нужно, чтобы верхняя граница действительно равнялась 200 (сейчас она равняется 151). Для этого нам нужно "вытянуть" массив, с этой задачей может помочь умножение. Как ты думаешь на какое число нужно умножить элементы массива?

Так как изначальный диапазон значений равнялся 1-0=1, а искомый диапазон равняется 200-150=50, нам нужно вытянуть числа в 50 раз. С этой задачей справляется умножение на 50. Однако при умножении на 50 элементы нашего массива становятся неадекватно большими...

```Python
arr_150_200 = arr_150 * 50
# [7527.26560107 7507.70465619 7501.75783067 7541.55541209 7507.22448629 7528.08873067 7501.74093355 7501.12562913 7525.60446751 7526.03338197 7536.506386 ]
```

Так происходит потому, что умножение не 50 сдвигает как правую границу значений, так и левую, поэтому диапазон [150,151] переходит в диапазон [7500,7550]. Его размах действительно 50, но границы оказываются совершенно не те

Значит нужно действовать в обратном порядке — сначала перевести диапазон [0,1] в [0,50] умножением на 50, а уже после добавить сдвиг и превратить диапазон [0,50] в [150, 200]

```Python
arr_0_50 = arr * 50
# [27.26560107 7.70465619 1.75783067 41.55541209 7.22448629 28.08873067 1.74093355 1.12562913 25.60446751 26.03338197 36.506386 ]

arr_150_200 = arr_0_50 + 100
# [177.26560107 157.70465619 151.75783067 191.55541209 157.22448629 178.08873067 151.74093355 151.12562913 175.60446751 176.03338197 186.506386 ]
```

Такая последовательность действий корректно решает задачу и успешно генерирует рост спортсменов
##### Целые случайные числа

TODO посмотреть на другие аргументы функции (как генерировать несколько элементов)

Мы не всегда хотим, чтобы результатом нашей генерации оказывалось дробное число — для радача задач гораздо лучше, чтобы оно было целым. За генерацию целых чисел отвечает функция np.random.randint(). Так как теперь нам вряд ли подходит генерация в диапазоне [0,1], функция np.random.randint() требует левую и правую границу генерации в качестве обязательных параметров. Трижды сгенерируем случайное целое число из диапазона [3,5]

```Python
np.random.randint(3,5)
# 3

np.random.randint(3,5)
# 4

np.random.randint(3,5)
# 3
```

Заметь, что в результате получились только тройки и четвёрки. Это не случайность — ровно как в функции range, наибольшее значение **исключается** из генерации. Для настоящей генерации целых чисел из диапазона [3,5] аргументами функции должны быть 3 и 6:

```Python
np.random.randint(3,6)
# 3

np.random.randint(3,6)
# 5

np.random.randint(3,6)
# 4
```

Теперь неименованные аргументы отвечают не за размер массива, а за границы генерации, поэтому для создания массива конкретного размера используется именованный аргумент size, получающий на вход кортеж. Сгенерируем массив из случайных чисел в диапазоне между [10,15] размера 3x3:

```Python
np.random.randint(10, 16, size=(3,3))
# [[10 11 11]
#  [11 12 14]
#  [14 10 10]]
```

Генерация целых чисел является полезным инструментом, позволяющем решать ряд задач и проводить симуляции экспериментов

FMT Пример
Петя поспорил с Васей, что ему везёт и он часто выбрасывает на кубике большие значения. Они решили сыграть в игру, разделённую на ранды. В ходе каждого раунда Петя должен подбросить кубик  5 раз: каждое выпадение 1, 2 и 3 идёт в зачёт Васе, а каждое выпадение 4, 5 и 6 — Пете. 

В раунде побеждает тот, у  кого в зачёте оказывается более количество бросков по итогам раунда. Игра проходит в 3 раунда — кто побеждает в большинстве их них оказывается прав в споре. Помоги друзьям определить победившего

Решение
Нам необходимо сгенерировать броски кубика — их результатами будут значения от 1 до 6. Так как в каждом раунде производится 5 бросков, будем представлять каждый раунд как одномерный массив длины 5, а так как всего раундов будет 3, составим двумерную таблицу — по строкам будут номера раундов, а по столбцам номера бросков в рамках раунда. Значит нам нужен массив размера 3x5

```Python
arr = np.random.randint(1,7, size=(3,5))
# [[3 1 2 6 5]
#  [5 5 6 4 3]
#  [3 4 6 6 4]]
```

Проанализируем полученный результат:
- 1 раунд:
	- 3 идёт в зачёт Васе
	- 1 идёт в зачёт Васе
	- 2 идёт в зачёт Васе
	- 6 идёт в зачёт Пете
	- 5 идёт в зачёт Пете
	
	В этом раунде со счётом 3:2 побеждает Вася

- 2 раунд
	- 5 идёт в зачёт Пете
	- 5 идёт в зачёт Пете
	- 6 идёт в зачёт Пете
	- 4 идёт в зачёт Пете
	- 3 идёт в зачёт Васе
	
	В этом раунде со счётом 4:1 побеждает Петя

- 3 раунд
	- 3 идёт в зачёт Васе
	- 4 идёт в зачёт Пете
	- 6 идёт в зачёт Пете
	- 6 идёт в зачёт Пете
	- 4 идёт в зачёт Пете
	
	В этом раунде со счётом 4:1 побеждает Петя

Петя победил в двух раундах из трёх, а значит смог доказать другу, что умеет выбрасывать большие числа. При этом наша симуляция случайно генерировала числа и вероятности победы, как Васи, так и Пети на самом деле были равны 50%

FMT ibox
Ядро генерации

##### У нас есть range дома (TODO не повторяюсь с этим приколом?)

TODO дописать норм вступление. Не обязательно абзац текста, просто не так криво начать подглаву
Также можно сходу создавать одномерные массивы, содержащие внутри себя арифметическую прогрессию как при написании `range`. Это делается с помощью метода `np.arange()` с привычными аргументами начала, конца и шага.

```Python
arr = np.arange(4)
# [0 1 2 3]

arr = np.arange(1, 10)
# [1 2 3 4 5 6 7 8 9]

arr = np.arange(1, 10, 2)
# [1 3 5 7 9]
```

### Булевы маски и логические выражения

### Работа с несколькими массивами

### Сортировка

### Бесконечность — не предел

### Статистики


### Сохранение и загрузка

Ты научился многим операциям с массивами в Numpy, однако для решения реальных задач массивы данных  нужно откуда-то получать, а результаты работы куда-то сохранять. К счастью, и это в Numpy делается легко и в одну команду. Cохранить массив можно командой `np.save()` передав туда имя файла и сохраняемый массив. Сохранение происходит в специальном формате `npy`, созданного для хранения Numpy массивов.

```Python
arr = np.array([1,2,3,4,5])

np.save("file_with_array.npy", arr)
```

После применения этой функции в директории исполняемого кода появится файл `file_with_array.npy`.

Открытие файла и его запись в массив происходит с помощью функции `np.load()`, которая получает на вход название файла:

```Python
arr = np.load("file_with_array.npy")
# [1 2 3 4 5]
```

### Заключение

Сегодня ты разобрал большое количество тем, которые закрывают потребности в использовании Numpy для подавляющего большинства сценариев. На этом мы заканчиваем изучение этой мощнейшей библиотеки для работы с данными и уже на следующем занятии разберём следующий, не менее важный инструмент, который является одним из стандартов для работы с таблицами — Pandas