>[!Tip]- Навыки (ПРОВЕРИТЬ, ЧТО В СЕМИНАРЕ И ДЗ ВСЁ ПРОВЕРЯЕМ)
>Создание массивов
>- [x] np.array()
>- [x] np.zeros(), np.ones(), np.empty()
>- [ ] np.eye(), np.identity() ЭТО НЕ НУЖНО
>
>Атрибуты массивов
>- [x] .shape, .ndim, .size
>- [x] .dtype
>
>Изменение формы массивов
>- [x] np.transpose(), .T
>- [x] .reshape()
>- [x] .flatten()
> 
>Индексация и срезы
>- [x] Базовая индексация: arr[0], arr[1, 2]
>- [x] Срезы: arr[start:stop:step], многомерные срезы [a:b:c, d:e:f]
>
>Арифметические операции
>- [x] +, -, (в том числе + число)
>- [x] *, /, 
>- [x] **, np.sqrt()
>- [x] np.exp())
>- [x] np.power()
>
>Агрегации
>- [ ] np.sum()
>- [ ] np.mean()
>- [ ] np.min(), np.max()
>- [ ] np.std()
>- [ ] np.median()
>- [ ] ОСИ
>- [ ] БРОАДКАСТ потом
>
>Сортировка и поиск
>- [ ] np.argmin(), np.argmax() (со звёздочкой)
>- [ ] np.unique()
>
>Работа с типами данных
>- [x] Приведение типов (.astype())
>- [ ] np.round()
>
Ввод/вывод
>- [x] np.save()
>- [x] np.load()

### Введение

Статистика — TODO сделать красивое вступление

Начало нашего пути в освоении статистики и анализа данных пройдёт через библиотеку Numpy — фундаментельный инструмент для работы с массивами данных в Python. Мы начнём с основ этой библиотеки, научимся базовым действиям, таким как применение арифметических операций, индексирование и аггрегация, а также изучим основы статистики, которые позже разовьём в полноценную практическую теорию. 

Наше изучение Numpy будет разделено на два занятия. На втором занятии мы пройдём те оставшиеся необходимые функции и возможности, которые не затронем здесь, а также разберём более сложные статистики на примерах с кодом.

Команда курса желает тебе удачи в освоении этой увлекательной науки! TODO сделать лучше
### Создание массивов и их атрибуты
##### Напоминание об ООП

Перед тем как погружаться в особенности Numpy повторим основы объектно-ориентированного программирования (ООП). Numpy, как и многие другие инструменты науки о данных, является **библиотекой** — подключаемым к коду модулем, содержащим полезные функции и классы. в Python библиотеки подключаются с помощью команды `import`
```Python
import numpy as np
```
Традиционно при подключении Numpy дают псевдоним `np`. Теперь, пользуясь псевдонимом, мы можем через точку обращаться к различным объектам библиотеки. Среди них конкретные объекты, такие как число пи
```Python
np.pi # 3.1415926...
```
И классы, такие как класс массива чисел `np.array`. Как и при работе с другими классами в Python, для создания **представителя** класса необходимо запустить инициализацию, дописав к имени класса скобки
```Python
# Класс
np.array

# Конкретный представитель класса, массив чисел
np.array()
```

Когда мы создали представителя класса, мы можем взаимодействовать с ним, производя действия с его внутренними значениями, **полями**, или вызывая его внутренние функции, **методы**. Так, у представителей `np.array` есть поле `dtype`, показывающее тип хранящихся в массиве данных, и метод `reshape`, менящий форму массива
```Python
# Создаём массив
arr = np.array()

# Получаем тип хранимых данных с помощью поля
dtype = arr.dtype 

# Меняем форму массива с помощью метода
arr.reshape(-1)
```

Заметил аргумент -1 внутри функции reshape? О его назначении и принципах работы этих полей и методов мы подробно поговорим ниже. 

Теперь, когда мы вспомнили основные понятия ООП, давай начнём изучение Numpy. Путь в тысячи ли начинается с первого шага, и нашим первым шагом будет создание массива данных

##### Инициализация массива и его форма

Как было сказано выше, для хранения данных в Numpy используется класс np.array. При его инициализации можно подать на вход коллекцию чисел (список или кортеж) и получить массив сразу из нужных значений

```Python
import numpy as np

arr = np.array([1,2,3,4,5])

# [1 2 3 4 5]
```

Numpy отлично работает с многомерными массивами (массивами, состоящими из массивов), поэтому при инициализации np.array можно подать на вход в том числе вложенный список

```Python
arr_2d = np.array([[1,2], [3,4], [5,6]])

# [[1 2] 
#  [3 4] 
#  [5 6]]
```

Мы создали двумерный массив, который можно интерепретировать как таблицу чисел размера 3x2. Из курса линейной алгебры ты узнаешь, что такие таблицы называются матрицами и поймёшь, как много у этого объекта полезных применений! А пока давай получим размер этого массива с помощью Numpy. Для того, чтобы выяснить количество измерений в массиве (степеней вложенности) достаточно просто посмотреть на поле `ndim`

```Python
arr_2d = np.array([[1,2], [3,4], [5,6]])

print(arr_2d.ndim)
# 2
```

Наш массив действительно имеет два измерения. А для того чтобы выяснить, какое количество объектов лежит вдоль каждого из измерений, используется одно из самых популярных полей `np.array` — `shape`

```Python
arr_2d = np.array([[1,2], [3,4], [5,6]])

print(arr_2d.shape)
# (3, 2)
```

Действительно, размер нашей таблицы чисел был равен 3x2. Заметим, что результат выдаётся в виде кортежа — так сделано потому что для формы массива критически важен порядок чисел. Для таких объектов традиционно используют кортеж, а не список, из-за его неизменяемости.

Наконец, давайте посчитаем общее количество элементов в массиве. Школьные знания подсказывают нам, что для этого нужно просто перемножить длины всех размерностей, то есть посчитать произведение элементов `np.shape`. Это действительно так, однако делать это вручную для многомерного массива может быть очень сложно. Специально для этого у `np.array` есть поле `size`

```Python
arr_2d = np.array([[1,2], [3,4], [5,6]])

print(arr_2d.size)
# 6
```

В реальных задачах, связанных со статистическим анализом, машинным обучением или эконометрикой, размерность массива может достигать десятков и сотен измерений, а общее число значений исчисляться миллионами. В таких случаях ручная проверка уже не поможет, и поля `size`, `shape` и `ndim` становятся действительно незаменимыми

```Python
# Пример пятимерного массива. 
# Определить его форму "вручную" сложнее, чем посмотреть поле shape

# [[[[[0. 0. 0. 0.]
#     [0. 0. 0. 0.]] 
#
#     [[0. 0. 0. 0.]
#      [0. 0. 0. 0.]] 
#
#     [[0. 0. 0. 0.]
#      [0. 0. 0. 0.]] 
#
# 
#     [[0. 0. 0. 0.]
#      [0. 0. 0. 0.]] 
#
#     [[0. 0. 0. 0.]
#      [0. 0. 0. 0.]] 
#
#     [[0. 0. 0. 0.]
#      [0. 0. 0. 0.]]]]]
```

##### Массивы из нулей и единиц

Иногда вместо создания массива из строго заданных значений бывает удобнее создать массив более простой структуры — из нулей, единиц или даже пустых значений, не заполненных ничем конкретным

Для создания массива из нулей используется функция `np.zeros()`. В качестве аргумента эта функция принимает на вход желаемую форму массива — всё так же в формате кортежа

```Python
arr_0 = np.zeros((3, 4))

# [[0. 0. 0. 0.]
#  [0. 0. 0. 0.]
#  [0. 0. 0. 0.]]
```

Аналогично, для создания массива из единиц, используется функция `np.ones()`

```Python
arr_1 = np.ones((2, 1, 3))

# [[[1. 1. 1.]] 
#
#  [[1. 1. 1.]]]
```

Если же необходимо создать пустой массив, то есть массив, в которой явно не записываются никакие значения, используется метод `np.empty()`
```Python
arr_emp = np.empty([2, 2])

# [[ -9.74499359e+001,   6.69583040e-309],
#  [  2.13182611e-314,   3.06959433e-309]])
```

В этом случае Numpy просто выделит память под нужный массив, но не будет записывать туда никакие значения. Полученные данные могут быть как упорядоченными, так и хаотичными — это зависит от того, какие значения записал туда последний процесс, работавший с этой областью памяти 

##### Типы данных

Заметили, что в последних примерах данные сохранялись в дробном формате, а в первых примерах мы наоборот создавали массивы из целых чисел? Давайте разберёмся с тем, как получать информацию о типе данных и изменять его

Если ты хочешь узнать тип данных массива, просто выведи поле `dtype` (data type). Создадим массив из целых чисел и выведем тип данных, в котором он хранится. Логично предположить, что результат будет в формате `int`

```Python
arr_int = np.array([3, 10])

print(arr_int)
# [3, 10]

print(arr_int.dtype)
# int64
```

Отлично, мы выяснили тип данных нашего массива! Оказывается, numpy хранит наши данные в формате `int64` (целочисленный формат, хранящий число в 64 битах). У Numpy есть целое множество внутренних типов данных и правил перевода из этих типов данных в другие, однако для всех наших задач будем считать, что тип данных `np.int64` идентичен типу `int` из стандартного Python

Что насчёт дробных чисел? Чтобы понять, в каком формате Numpy их сохраняет, создадим массив с дробными значениями, например числами $e$ и $\pi$, причём сделаем это с помощью констант из самой библиотеки Numpy

```Python
# массив из числа е и числа пи
arr_float = np.zeros((np.e, np.pi))

print(arr_float)
# [2.71828183 3.14159265]

print(arr_float.dtype)
# float64
```

По аналогии дробные числа хранятся в формате `np.float64`. 

Нужный тип данных для данных можно задать сразу при инициализации с помощью необязательно аргумента dtype — это работает как со стандартной инициализацией `np.array()`, так и с `np.zeros()`, `np.ones()`, `np.empty()`

```Python
arr_1 = np.array([np.e, np.pi])
# [2.71828183 3.14159265]

# Тот же массив, но с типом данных np.int64
arr_2 = np.array([np.e, np.pi], dtype=np.int64)
# [2 3]

zeros_1 = np.zeros((2))
# [0. 0.]

# Тот же массив, но с типом данных np.int64
zeros_2 = np.zeros((2), dtype=np.int64)
# [0 0]
```

При этом тип данных массива можно менять и на ходу. Для этого используется метод `astype`, в котором в качестве аргумента указывается нужный тип данных для данного массива

```Python
# массив из числа е и числа пи
arr_float = np.zeros((np.e, np.pi))

print(arr_float)
# [2.71828183 3.14159265]

# Тип данных будет отличаться!
print(arr_float.astype(np.int64))
# [2 3]
```

У нас успешно получилось перевести числа из дробного формата `np.float64` в целочисленный `np.int64`. Однако следует помнить, что метод `.astype()`, как множество других методов в Numpy, работает "не на месте"

##### На месте VS Не на месте

Для работы с данными в Python критически важно разобраться в одном ньюансе работы методов и функций

Дело в том, что все методы и функции, изменяющие данные, по своей природе делятся на два типа:
- Те, что делают это "на месте" (in-place), то есть изменяют объект, с которым работали
- Те, что делают это "не на месте" (out-of-place), то есть не изменяют объект, с которым работали, а вместо этого создают новый объект, в котором лежат изменённые данные

Для того, чтобы разобраться в разнице между этими типами преобразований, рассмотрим стандартный список в Python и два способа отсортировать его — `sorted()` и `.sort()`

 - При применении метода `.sort()` мы меняем тот объект, с которым работали. Так как кроме этого от метода `.sort()` ничего не требуется, этот метод ничего не возвращает в качестве результата своей работы. В этом нет необходимости, так как список уже изменён и отсортирован!
 
```Python
# Создаём список
l = [3,1,5,4,2]

# Применяем метод .sort() и сохраняем результат его работы
result = l.sort()

print(l, result)
# [1,2,3,4,5] None
```

Видим, что результат оказался пустым, поскольку свою цель `.sort()` уже выполнил и отсортировал список `l`. Таким образом, `.sort()` работает **"на месте"**

- При применении функции `sorted()` мы не меняем изначальные данные. Как же мы тогда получаем отсортированный массив? Как раз с помощью возвращаемого значения!
```Python
l = [3,1,5,4,2]

# Применяем функцию sorted() и сохраняем результат её работы
result = sorted(l)

print(l, result)
# [3,1,5,4,2] [1,2,3,4,5]
```

Мы видим неизменный изначальный массив и новый возвращённый массив, в котором лежит результат работы функции! 

Так как в работе с данными многие действия появляются в процессе экспериментов, хочется оставлять за собой возможность отменить действие и вернуться к предыдущему шагу. Поэтому зачастую методы, которые мы будем использовать, будут работать "не на месте". Будьте внимательны, поскольку для таких методов обязательно требуется создать новую переменную, в которую будет положен результат, без этого он будет безвозвратно утерян!

```Python
l = [3,1,5,4,2]

sorted(l)

print(l)
# [3,1,5,4,2]
```
Здесь мы применили функцию `sorted()`, работающую "не на месте" и не сохранили результат. В итоге он оказался утерян, изначальный список не поменялся и функция отработала напрасно

- - -

TODO (round)

### Индексация

Мы научились создавать массив данных, определять его размер и тип данных, и теперь как и в любой другой коллекции, важно научиться индексироваться по конкретным объектам. К счастью Numpy предоставляет для этого очень удобный функционал

Представим, что в качестве данных нам сообщили двумерную таблицу 3x3, состоящую из чисел от 1 до 9:

```Python
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]
```

Как и в стандартных списках, в np.array работает обычный выбор элемента по индексу. Возьмём элемент массива с индексом 1 (так как элементами нашего массива являются массивы строк таблицы, выберется соответствующая строка):

```Python
arr[1]

# [4 5 6]
```

Как ты видишь, всё работает так же, как и в стандартных коллекциях Python. А теперь давай возьмём из этой строки последний элемент (индекс 2). Сделать это можно по-привычному с помощью нескольких индексаций подряд:

```Python
# Последний элемент строки с индексом 1
arr[1][2]

# 6
```

Однако в Numpy существует и другой, более лаконичный способ задать вложенную индексацию. Для этого можно перечислить все индексы в рамках одних квадратных скобок один за другим через запятую:

```Python
arr[1, 2]

# 6
```

Такого стандартные списки Python нам предложить уже не могут. Этот способ выглядит лаконичнее и является более принятым при работе с Numpy

- - -

Также в качестве индекса работают и срезы. Возьмём строки, начиная с первой (индекс 0) через одну с помощью среза:

```Python
arr[0::2]

# [[1 2 3] 
#  [7 8 9]]
```

Теперь попробуем взять все столбцы у этих строк, кроме самого первого. Для этого аналогично примеру выше можно использовать запись индексов через запятую:

```Python
# Строки, начиная с нулевой с шагом в 2 
# и столбцы, начиная с первого
arr[0::2, 1:]

# [[2 3] 
#  [8 9]]
```

Заметь, что стандартный способ с несколькими индексациями тут уже не сработает, так как вторая индексация будет рассматривать как объекты отобранные первой индексацией строки, и просто ещё раз профильтрует эти строки

```Python
# Строки, начиная с нулевой с шагом в 2, 
# И СРЕДИ НИХ строки, начиная с первой
arr[0::2][1:]

# [[7 8 9]]

```
### Арифметика

Чтобы производить подсчёты над данными, необходимо уметь применять арифметические операции к нашим массивам. Начнём с простейшего — суммы. 

В Numpy можно прибавлять к массиву число — в таком случае оно прибавится ко всем элементам массива. Возьмём массив `arr1` из предыдушей главы и добавим ко всем его элементам 10

```Python
arr1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]

arr1 + 10
# [[11 12 13] 
#  [14 15 16] 
#  [17 18 19]]
```


Также ты можешь складывать массивы одинаковых размеров друг с другом — в таком случае сложение произойдёт поэлементно. Возьмём массив `arr1` из предыдушей главы и добавим к нему массив из единиц той же формы, что и `arr1` — это можно сделать используя уже знакомое нам поле `shape`

```Python
arr1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]

# Массив из целых единиц размером 3x3
arr2 = np.ones(arr1.shape, , dtype=np.int64)
# [[1 1 1] 
#  [1 1 1] 
#  [1 1 1]]

# Сложим два массива
arr1 + arr2
# [[2 3 4] 
#  [5 6 7] 
#  [8 9 10]]
```

>[!note] Приведение размеров
>На следующем занятии мы увидим, что Numpy позволяет проводить операции и с массивами разных размеров, если однозначно понятно правило, по которому один массив можно привести к размерам другого. 
>
>Это приведение размеров (broadcasting) позволяет в том числе складывать массивы разных размеров, но подробнее мы изучим это позже

Разумеется, тот же принцип относится и к вычитанию:

```Python
arr1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]

# Массив из целых единиц размером 3x3
arr2 = np.ones(arr1.shape, , dtype=np.int64)
# [[1 1 1] 
#  [1 1 1] 
#  [1 1 1]]

# Вычтем из каждого элемента 10
arr1 - 10
# [[-9 -8 -7] 
#  [-6 -5 -4] 
#  [-3 -2 -1]]

# Вычтем один массив из другого
arr1 - arr2
# [[0 1 2] 
#  [3 4 5] 
#  [6 7 8]]
```

- - -

Аналогично работает произведение массива на число:

```Python
arr1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]

arr1 * 10
# [[10 20 30] 
#  [40 50 60] 
#  [70 80 90]]
```

И массива на массив. Умножим все элементы массива `arr1` на 2 поэлементно, используя массив того же размера, состоящий из двоек (для этого можно умножить на 2 массив ones)

```Python
arr1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]

# Массив из целых двоек размером 3x3
arr2 = np.ones(arr1.shape, dtype=np.int64) * 2
# [[2 2 2] 
#  [2 2 2] 
#  [2 2 2]]

arr1 * arr2
# [[2  4  6] 
#  [8  10 12] 
#  [14 16 20]]
```

Деление тоже работает предсказуемо, однако следует помнить, что как и в стандартном Python результат деления двух чисел (даже если это целые числа, нацело делящиеся друг на друга) будет дробным числом. Поделим наш массив `arr1` на 2 с помощью деления на число, а затем поэлементно поделим на 1, чтобы убедиться, что в результате получится дробное число

```Python
arr1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]

# Массив из целых единиц размером 3x3
arr2 = np.ones(arr1.shape, dtype=np.int64)
# [[1 1 1] 
#  [1 1 1] 
#  [1 1 1]]

arr1 / 2
# [[0.5 1. 1.5] 
#  [2. 2.5 3. ] 
#  [3.5 4. 4.5]]

# Даже при делении на 1 получаем дробный результат
arr1 / arr2
# [[1. 2. 3.] 
#  [4. 5. 6.]
#  [7. 8. 9.]]

print((arr1 / arr2).dtype)
# float64
```

- - - 

Для возведения в степень можно использовать `**` из стандартного синтаксиса Python или функцию `np.power()`, принимающую на вход массив и необходимую степень

```Python
arr1 ** 2
# [[ 1 4 9] 
#  [16 25 36]
#  [49 64 81]]

# То же, что arr1 ** 2
np.power(arr1, 2)
# [[ 1 4 9] 
#  [16 25 36]
#  [49 64 81]]
```

Для взятия корня можно использовать свойства степеней ($\sqrt{arr} = arr^{0.5}$ = `arr ** 0.5`) или напрямую воспользоваться функцией `np.sqrt()`

```Python
arr1 ** 0.5
# [[1. 1.41421356 1.73205081]
#  [2. 2.23606798 2.44948974]
#  [2.64575131 2.82842712 3. ]]

# То же, что arr ** 0.5
np.sqrt(arr1)
# [[1. 1.41421356 1.73205081]
#  [2. 2.23606798 2.44948974]
#  [2.64575131 2.82842712 3. ]]
```

Для некоторых формул в высшей математике требуется рассматривать числа в массиве как степени числа $e$, то есть для каждого числа $x$ из массива делать преобразование $x \rightarrow e^x$. Это возможно сделать с помощью функции `np.exp()`

```Python
arr1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]

np.exp(arr1)
# [[2.71828183e+00 7.38905610e+00 2.00855369e+01]
#  [5.45981500e+01 1.48413159e+02 4.03428793e+02]
#  [1.09663316e+03 2.98095799e+03 8.10308393e+03]]
```

### Изменение формы

Как вы могли заметить, для ряда операций важно, чтобы у массивов чисел были совместимые формы. В случае, если по какой-то причине (а таких причин на практике возникает довольно много) нам понадобится поменять размеры нашего массива, следует воспользоваться методом `reshape()`, получающим на вход форму желаемого массива. Как вы уже догадались, принимается она в том числе в формате кортежа. 

Давайте применим метод reshape к массиву из прошлой главы. Представим числа от 1 до 9 как обычную одномерную последовательность размера 9, а не как двумерную таблицу размера 3x3

```Python
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]

print(arr.shape)
# (3, 3)

new_arr = arr.reshape((9))

print(new_arr)
# [1 2 3 4 5 6 7 8 9]

print(new_arr.shape)
# (9)
```

У нас получилось поменять размер массива, оставив на месте все значения и сохранив их порядок! Метод `reshape()` работает не на месте, поэтому при его вызове мы создаём новую переменную `new_arr`.

Метод `reshape` имеет очевидные ограничения — перевести массив размера (3x3) к размеру (100x50x10), к сожалению, не выйдет, так как общее количество элементов у этих размеров разное
```Python
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]

new_arr = arr.reshape((100, 50, 10))
# ValueError
```

Кажется, что из-за этого ограничения нам каждый раз придётся подсчитывать количество элементов вдоль каждого из измерений и следить, чтобы количество элементов оставалось неизменным. Делать это настолько дотошно для массивов с большим количеством измерений не хочется, поэтому в методе `reshape` есть одно очень удобное послабление

Если у вас имеется массив из 100 элементов, и в методе reshape вы указали, что всего вы хотите получить 3 измерения, а первые 2 измерения имеют размер 5 и 5, мы можем однозначно подсчитать размер последнего измерения ($5 \cdot 5 \cdot x = 100$).

Иногда нам бывает важно задать только часть размера массива, а в оставшуюся размерность поместить "всё остальное". Для этого в `reshape` на месте этой оси следует написать `-1` — увидев это значение в качестве размера одного из измерений Numpy автоматически посчитает нужное значение

```Python
arr = np.zeros((100))

# Не указываем последнее измерение
# Оставляем это на подсчёт Numpy
new_arr = arr.reshape((5, 5, -1))

new_arr.shape
# (5, 5, 4)
```

Действительно, массив размера 5x5x4 содержит 100 элементов, как и было в изначальном массиве!

Автоматический подсчёт размера одного из измерений очень удобен. Например, он позволяет легко "выпрямить" любой массив в одномерную последовательность:

```Python
# Многомерный массив. Как его можно "выпрямить?"
arr = np.zeros((3,5,1,4,10,7,3))

new_arr = arr.reshape((-1))

# Оказалось, в этом массиве 12600 элементов
# Numpy посчитал это за нас
new_arr.shape
# 12600
```

К слову, подобное "выпрямление" многомерного массива в одно измерение возможно и отдельным методом! Так как одномерные массивы выглядит как "плоские", однострочные последовательности, такие массивы так и называют — flat (плоские), а метод приведения к плоскому массиву — `flatten`

```Python
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]

new_arr = arr.flatten()
# [1 2 3 4 5 6 7 8 9]
```

Вернёмся к значению -1, позволяющему автоматически выбрать необходимый размер измерения: у такого автоматического подсчёта тоже есть свои ограничения. Например, не всегда существует **целый** размер измерения, попадающий под условия (5 элементов нельзя перевести в таблицу с 3 строками). Чтобы этого избежать, следует задавать размеры так, чтобы общее количество элементов быть кратно произведению всех остальных значений, указанных явно

```Python
arr = np.zeros((100))

# Работает без ошибок, т.к. 100 делится на 5*5=25
# Оставшийся размер равен 100 / 25 = 4
new_arr = arr.reshape(5, -1, 5)

# Выдаст ошибку, т.к. 100 не делится на 3*17=51
new_arr = arr.reshape(3, -1, 17)
# ValueError
```

Также нельзя указывать более одной -1, так как почти всегда это приводит к неоднозначности подсчёта

```Python
arr = np.zeros((100))

# Выдаст ошибку, т.к. существует несколько способ подсчёта размеров
# 10 * 10 * 1 = 100
# 10 * 5  * 2 = 100
# 10 * 2  * 5 = 100
# 10 * 1 * 10 = 100
new_arr = arr.reshape(10, -1, -1)
# ValueError
```

Однако даже несмотря на все эти ограничения, автоматический подсчёт размера массива — очень полезная и активно применяющаяся на практике функция, которая не раз поможет вам в ходе экспериментов

#### Транспонирование

Ещё одной полезной операцией при работе с массивами является транспонирование — переворот массива, меняющий местами два измерения. В случае двумерных таблиц это означает перевод строк в столбцы, а столбцов в строки. Форма массива при этом не меняется. Делается это с помощью метода `transpose` (работает не на месте) или сокращения `T` — оно взято из линейной алгебры, где операция транспонирования является одной из основных:

```Python
arr1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# [[1 2 3] 
#  [4 5 6] 
#  [7 8 9]]

# Столбцы и строки поменялись местами
arr2 = arr1.transpose()
# [[1 4 7] 
#  [2 5 8]
#  [3 6 9]]

# Вместо вызова метода transpose можно взять атрибут T
arr3 = arr1.T
# [[1 4 7] 
#  [2 5 8]
#  [3 6 9]]

```
TODO (нужны оси)
### Сохранение и загрузка

Ты научился проводить базовые операции с Numpy, однако пока едва ли способен решить какую-то реальную задачу, потому что массивы данных  нужно откуда-то получать, а результаты работы куда-то сохранять. К счастью, и это в Numpy делается легко и в одну команду. Cохранить массив можно командой `np.save()` передав туда имя файла и сохраняемый массив. Сохранение происходит в специальном формате `npy`, созданного для хранения Numpy массивов.

```Python
arr = np.array([1,2,3,4,5])

np.save("file_with_array.npy", arr)
```

После применения этой функции в директории исполняемого кода появится файл `file_with_array.npy`. Открытие файла и его запись в массив происходит с помощью функции `np.load()`, которая получает на вход название файла:

```Python
arr = np.load("file_with_array.npy")
# [1 2 3 4 5]
```

### Статистики (в том числе argmax)

Из названия курса понятно, что библиотека Numpy нас не в последнюю очередь интересует с точки зрения статистического анализа, поэтому в этой главе давайте разберемся с основными значениями в статистике и тем, как с ними работать в Numpy
##### Распределение

Статистика работает с данными, подчиняющимися определённым законам и чья случайность описывается определёнными правилами. Эти правила, описывающие случайность, называются **распределением**. Так, результат броска кубика подчиняется равномерному распределению (все результаты равновероятны), а количество орлов при пятикратном подбрасывании монеты биномиальному распределению (пять орлов гораздо менее вероятны, чем три орла). 

О видах распределений и их более строгом определении мы поговорим позже. Сейчас важно понимать, что распределение — это идеальное математическое правило, описывающее характер случайности
##### Выборка

Любая практическая задача это прежде всего работа с конкретными данными, а не с идеальной математической моделью случайности. Такой конкретный набор данных называется **выборкой** — это конкретные числа, которые, как мы предполагаем, были получены из некоторого идеального математического распределения

Важно понимать, что вид идеального математического распределения и вид конкретной выборки могут отличаться. Так, идеальное равномерное распределение предполагает, что вероятность выпадания на кости единицы такая же, как вероятность выпадания шестёрки, однако в конкретной полученной выборке может оказаться сто единиц и не оказаться ни одной шестёрки
##### Статистика

И модельные математические распределения, и полученные на практике выборки нужны, чтобы производить нам ними подсчёты. Нередко оказывается удобно саггрегировать сложный закон случайности в одно лаконичное число. Такое число, полученное на основе распределения случайности называется как и наука — **статистикой**. 

Статистики считают как на основе распределений, так и на основе конкретных выборок. Во втором случае их называют **выборочными** и подразумевают, что статистика основана на конкретных числах и не обязательно точно показывает характеристику математического распределения. 

В ходе ближайший занятий мы будем заниматься исключительно выборочными статистиками и оставим подсчёт настоящих статистик на потом. Начнём изучение статистик с, пожалуй, самого популярного и информативного числа для всей выборки — среднего
##### Выборочное среднее

Среднее — это статистика, которая не нуждается в представлении. Для выборки $x_1, x_2, \dots, x_n$
$$mean = \frac{x_1+x_2+\dots+x_n}{n}$$
Выборочное среднее говорит о центре тяжести выборки, том значении, которое ближе находится ко всем данным выборки. Среднее является полезным числом для любой выборки, однако в её использовании стоит быть аккуратным — одна из проблем выборочного среднего в том, что оно чувствительно к **выбросам**, то есть данным, сильно выбивающимся из общей тенденции

Например, выборки $[1,3,2,3,1]$ и $[2,3,2,3,1000]$ похожи по своему характеру, не считая очевидный выброс в виде числа 1000. Такой выброс мог появиться случайно, например из-за ошибки при переносе данных в компьютер. При этом среднее первой выборки равняется
$$mean_1 = \frac{1 + 3 + 2 + 3 + 1}{5} = 2$$
А среднее второй выборки оказывается на порядок больше
$$mean_2=\frac{2+3+2+3+1000}{5} = 202$$
Поэтому при подсчёте среднего важно заранее убрать все выбросы, чтобы среднее не было смещено. О том, как вычислять выбросы, мы поговорим на пятом занятии

- - -

В Numpy для подсчёта выборочного среднего используется функция `np.mean()` (от английского mean — среднее), принимающая на вход массив

```Python
arr1 = np.array([[1, 2], [3, 4]])
# [[1 2]
#  [3 4]]

# (1 + 2 + 3 + 4) / 4 = 2.5
print(np.mean(arr1))
# 2.5
```

Также `np.mean()`, как и остальные агрегации, можно подсчитывать вдоль осей, указав необязательный параметр `axis`

```Python
arr1 = np.array([[1, 2], [3, 4]])
# [[1 2]
#  [3 4]]

# (1 + 3) / 2 = 2
# (2 + 4) / 2 = 3
np.mean(arr1, axis=0)
# [2. 3.]

# (1 + 2) / 2 = 1.5
# (3 + 4) / 2 = 3.5
np.mean(arr1, axis=1)
# [1.5 3.5]
```

##### Выборочная Медиана

Представь, что тебе дали информацию о зарплатах людей в какой-то стране, и ты хочешь понять общий "масштаб" этих зарплат. Как мы выяснили, выборочное среднее является не лучшим выбором, потому что оно может сильно поменяться при наличии выбросов (например, несколько очень богатых людей сместят информацию о среднем). Вместо этого в голову может прийти идея посмотреть на зарплату "среднего" человека, отсортировав всех по зарплатам и взяв число из середины. Именно этим и является выборочная медиана. 

Разберёмся с тем, как обозначать отсортированную выборку: при сортировке выборки $x_1, x_2, \dots , x_n$ значения поменяют свой порядок, и индексы будут идти в каком-то другом порядке $x_*, x_*, \dots, x_*$. Для отсортированной выборки номер первой по порядку величины принято обозначать в скобках — это указывает на упорядоченность объектов: $x_{(1)}, x_{(2)}, \dots, x_{(n)}$

Теперь мы готовы дать определение медианы — для упорядоченной выборки $x_{(1)}, x_{(2)}, \dots, x_{(n)}$ медиана, кажется, считается как
$$median = x_{(n/2)}$$

Внимательный читатель сразу задастся вопросом — как быть, если среднего элемента нет? Действительно, на самом деле для выборок с чётным и нечётным количеством элементов правила подсчёта медианы немного разные. Разберёмся подробнее.

Если выборка содержит нечётное количество элементов, среднее значение легко определяется (например для выборки $[1,3,7,8,10]$ это будет 7), но технически формула для подсчёта будет другой, ведь у выборки нечётного размера не существует элемента с индексом $\frac{n}{2}$, вместо него нам подойдёт $\frac{n+1}{2}$ (если считать с единицы)

Если же выборка содержит чётное количество элементов, есть проблема — у неё нет среднего (например для выборки $[1,3,7,8]$ средними являются одновременно и 3 и 7). Можно было бы выбрать в качестве медианы левое среднее или правое среднее значение, но любое из этих решений было бы необоснованно, ведь среди этих чисел нет более "главного". Именно поэтому в случае с чётным размером выборки медиана считается как **среднее** двух средних чисел. Эти числа находятся под индексами $\frac{n}{2}$ и $\frac{n}{2} + 1$

Теперь мы можем дать полноценное определение медианы. Из-за описанных выше ньюансов определение разбивается на два разных случая:

$$median=\begin{cases}x_{(\frac{n+1}{2})}, \text{если}\;n\;\text{нечётно}\\ \frac{x_{(\frac{n}{2})} + x_{(\frac{n}{2} + 1)}}{2}, \text{если}\;n\;\text{чётно}\end{cases}$$

Медиана очень устойчива к выбросам, и в этом отношении лучше, чем среднее, однако она заостряет внимание на одном (максимум двух) объектах выборки, не давая никакой информации об остальных объектах, в то время как на среднее понемногу влияет каждый элемент выборки 

- - -

В Numpy для подсчёта выборочной медианы используется функция `np.median()`. Её также можно запустить вдоль конкретных осей с помощью аргумента `axis`:

```Python
arr1 = np.array([[1, 2, 3], [4, 5, 6]])
# [[1 2 3]
#  [4 5 6]]

# (3 + 4) / 2 = 3.5
np.median(arr1)
# 3.5

# (1 + 4) / 2 = 2.5
# (2 + 5) / 2 = 3.5
# (3 + 6) / 2 = 4.5
np.median(arr1, axis=0)
# [2.5 3.5 4.5]

np.median(arr1, axis=1)
# [2. 5.]
```

##### Выборочные минимум и максимум

Что может быть проще, чем просто найти наибольший и наименьший элемент в выборке? Действительно, выборочный максимум и выборочный минимум являются одними из самых простых в описании статистик. Для выборки $x_1, x_2, \dots, x_n$ выборочным максимум будет
$$max = max(x_1, x_2, \dots, x_n) = x_{(n)}$$
А выборочным минимумом
$$min = min(x_1, x_2, \dots, x_n) = x_{(1)}$$
На практике иногда интересен в том числе **размах** выборки, то есть покрываемый ею диапазон значений:

$$range = max - min$$
- - -

В Numpy для максимума и минимума существуют функции `np.max()` и `np.min()`, поддерживающие работу с осями

```Python
arr1 = np.array([[1, 2, 3], [4, 5, 6]])
# [[1 2 3]
#  [4 5 6]]

print(np.min(arr1))
# 1

print(np.min(arr1, axis=0))
# 1 2 3

print(np.min(arr1, axis=1))
# 1 4

print(np.max(arr1))
# 6

print(np.max(arr1, axis=0))
# 4 5 6

print(np.max(arr1, axis=1))
# 3 6
```

#####  Выборочная дисперсия

Разброс между

### Заключение

Поздравляю, теперь вы умеете базово работать с Numpy и уже способны использовать эту библиотеку для решения задач! Сегодня мы разобрали способы создания массивов, типы данных, способы индексации, работу с арифметиков и изменение формы массивов. Не менее важно, что мы разобрали основные статистики, среди них — среднее, медиана, мода, дисперсия. 

Но самое интересное всё ещё впереди — на следующем занятии мы научимся применять фильтры и строить булевы маски, производить конкатенацию массивов, сортировать данные в массиве, а также разберём более продвинутые статистики. Все эти знания послужат крепким фундаментом для дальнешей работе на курсе

TODO unqiue
TODO навыки