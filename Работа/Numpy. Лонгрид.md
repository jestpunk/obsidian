>[!Tip]- Навыки (ПРОВЕРИТЬ, ЧТО В СЕМИНАРЕ И ДЗ ВСЁ ПРОВЕРЯЕМ)
>Создание массивов
>- [x] np.array()
>- [ ] np.zeros(), np.ones(), np.empty()
>- [ ] np.eye(), np.identity() ЭТО НЕ НУЖНО
>
>Атрибуты массивов
>- [x] .shape, .ndim, .size
>- [ ] .dtype
>
>Изменение формы массивов
>- [ ] np.transpose(), .T
>- [ ] .reshape()
>- [ ] .flatten(), .ravel()
> 
>Индексация и срезы
>- [ ] Базовая индексация: arr[0], arr[1, 2]
>- [ ] Срезы: arr[start:stop:step], многомерные срезы [a:b:c, d:e:f]
>
>Арифметические операции
>- [ ] +, -, (в том числе + число)
>- [ ] *, /, 
>- [ ] **, np.sqrt()
>- [ ] np.exp())
>- [ ] np.power()
>
>Агрегации
>- [ ] np.sum()
>- [ ] np.mean()
>- [ ] np.min(), np.max()
>- [ ] np.std()
>- [ ] np.median()
>- [ ] ОСИ
>
>Сортировка и поиск
>- [ ] np.argmin(), np.argmax() (со звёздочкой)
>- [ ] np.unique()
>
>Работа с типами данных
>- [ ] Приведение типов (.astype())
>- [ ] np.round()
>
Ввод/вывод
>- [ ] np.save()
>- [ ] np.load()

### Введение
Статистика — TODO сделать красивое вступление

Начало нашего пути в освоении статистики и анализа данных пройдёт через библиотеку Numpy — фундаментельный инструмент для работы с массивами данных в Python. Мы начнём с основ этой библиотеки, научимся основным действиям, таким как применение арифметических операций, индексирование и аггрегация, а также изучим основы статистики, которые позже разовьём в полноценную практическую теорию. 

Наше изучение Numpy будет разделено на два занятия. На втором занятии мы пройдём те оставшиеся необходимые функции и действия, которые не затронем здесь, а также разберём более сложные статистики на примерах с кодом.

Итак, начнём освоение этой увлекательной науки через призму библиотек в Python, а для того, чтобы ориентироваться в дальнейших примерах кода, начнём с повторения основ объектно-ориентированного программирования ООП (Python)
### Начало работы. Создание массивов + атрибуты
##### Напоминание об ООП
Numpy, как и многие другие инструменты науки о данных, является **библиотекой** — подключаемым к коду модулем, содержащим полезные функции и классы. в Python библиотеки подключаются с помощью команды `import`
```Python
import numpy as np
```
Традиционно при подключении numpy дают псевдоним `np`. Теперь, пользуясь псевдонимом, мы можем через точку обращаться к различным объектам библиотеки. Среди них конкретные объекты, такие как число пи
```Python
np.pi # 3.1415926...
```
И классы, такие как класс массива чисел `np.array`. Как и при написании собственных классов, для создания **представителя** класса необходимо запустить инициализацию класса, дописав к его имени скобки
```Python
# Класс
np.array

# Конкретный представитель класса, массив чисел
np.array()
```

Когда мы создали представителя класса, мы можем с ним взаимодействовать, производя действия с его внутренними значениями, **полями**, или вызывая его внутренние функции, **методы**. Так, у представителей `np.array` есть поле `dtype`, показывающее тип хранящихся в массиве данных, и метод `reshape`, менящий форму массива
```Python
# Создаём массив
arr = np.array()

# Получаем тип хранимых данных
dtype = arr.dtype 

# Меняем форму массива
arr.reshape(-1)
```

Заметил -1 в качестве аргумента внутри функции reshape? О его назначении и принципах работы этих полей и методов мы подробно поговорим ниже. 

Теперь, когда мы вспомнили основные понятия ООП, давайте начнём изучение Numpy. Путь в тысячи ли начинается с первого шага, и нашим первым шагом будет создание массива данных

##### Создание массива и его форма
Как было сказано выше, для хранения данных в Numpy используется класс np.array. При его инициализации можно подать на вход коллекцию чисел (список или кортеж) и получить массив сразу из нужных значений

```Python
import numpy as np

arr = np.array([1,2,3,4,5])
print(arr) 
# [1 2 3 4 5]
```

Numpy отлично работает с многомерными массивами (массивами, состоящими из массивов), поэтому при инициализации np.array можно подать на вход в том числе вложенный список

```Python
arr_2d = np.array([[1,2], [3,4], [5,6]])

print(arr_2d)
# [[1 2] 
#  [3 4] 
#  [5 6]]
```

Мы создали двумерный массив, который можно интерепретировать как таблицу чисел размера 3x2. Из курса линейной алгебры ты узнаешь, что такие таблицы называются матрицами и поймёшь, как много у этого объекта полезных применений! А пока давайте получим размер полученного массива с помощью Numpy. Для того, чтобы выяснить количество измерений в массиве (степеней вложенности) достаточно просто посмотреть на поле `ndim`

```Python
arr_2d = np.array([[1,2], [3,4], [5,6]])

print(arr_2d.ndim)
# 2
```

Наш массив действительно имеет два измерения! А для того чтобы выяснить, какое количество объектов лежит вдоль каждого из измерений, используется одно из самых популярных полей `np.array` — `shape`

```Python
arr_2d = np.array([[1,2], [3,4], [5,6]])

print(arr_2d.shape)
# (3, 2)
```

Действительно, размер нашей таблицы чисел действительно был равен 3x2. Заметим, что результат выдаётся в виде кортежа — так сделано потому что в форме массива критически важен порядок чисел. Для таких объектов традиционно используют кортеж, а не список, из-за его неизменяемости.

Наконец, давайте посчитаем общее количество элементов в массиве. Школьные знание подсказывают нам, что для этого нужно просто перемножить длины всех размерностей, то есть посчитать произведение элементов `np.shape`. Это действительно так, однако делать это вручную для многомерного массива может быть очень сложно. Специально для этого у `np.array` есть поле `size`

```Python
arr_2d = np.array([[1,2], [3,4], [5,6]])

print(arr_2d.size)
# 6
```

В реальных задачах, связанных со статистическим анализом, машинным обучением или эконометрикой, размерность массива может достигать десятков и сотен измерений, а общее число значений исчисляться миллионами. В таких случаях ручная проверка уже не поможет, и поля `size`, `shape` и `ndim` становятся действительно незаменимыми

```Python
# Пример пятимерного массива. 
# Определить его форму "вручную" сложнее, чем посмотреть поле shape

# [[[[[0. 0. 0. 0.]
#     [0. 0. 0. 0.]] 
#
#     [[0. 0. 0. 0.]
#      [0. 0. 0. 0.]] 
#
#     [[0. 0. 0. 0.]
#      [0. 0. 0. 0.]] 
#
# 
#     [[0. 0. 0. 0.]
#      [0. 0. 0. 0.]] 
#
#     [[0. 0. 0. 0.]
#      [0. 0. 0. 0.]] 
#
#     [[0. 0. 0. 0.]
#      [0. 0. 0. 0.]]]]]
```

##### Массивы из нулей и единиц

Иногда вместо создания массива из строго заданных значений бывает удобнее создать массив более простой структуры — из нулей, единиц или вообще незаполненный ничем конкретным

Для создания массива из нулей используется функция `np.zeros()`. В качестве аргумента эта функция принимает на вход желаемую форму массива — всё так же в формате кортежа

```Python
arr_0 = np.zeros((3, 4))

# [[0. 0. 0. 0.]
#  [0. 0. 0. 0.]
#  [0. 0. 0. 0.]]
```

Аналогично, для создания массива из единиц, используется функция `np.ones()`

```Python
arr_1 = np.zeros((2, 1, 3))

# [[[1. 1. 1.]] 
#
#  [[1. 1. 1.]]]
```

Если же необходимо создать пустой массив, то есть массив, в которой явно не записываются никакие значения, используется метод `np.empty()`
```Python
arr_emp = np.empty([2, 2])

# [[ -9.74499359e+001,   6.69583040e-309],
#  [  2.13182611e-314,   3.06959433e-309]])
```

В этом случае Numpy просто выделит память под нужный массив, но не будет записывать туда никакие значения. Полученные данные могут быть как упорядоченными, так и хаотичными — зависит это от того, какие значения записал последний процесс, работавший с этой областью памяти 

##### Типы данных

Заметили, что в последних примерах данные сохранялись в дробном формате, а в первых примерах мы наоборот создавали массивы из целых чисел. Давайте разберёмся с тем, как получать информацию о типе данных и изменять его

Если ты хочешь узнать тип данных массива, просто выведи поле `dtype` (data type). Создадим массив из целых чисел выведем тип данных, в которых он хранится. Судя по природе значений ($e$ и $\pi$ не целые числа) логично предположить, что результат будет в формате `int`

```Python
arr_int = np.array([3, 10])

print(arr)
# [3, 10]

print(arr.dtype)
# int64
```

Отлично, мы выяснили тип данных нашего массива! Оказывается, numpy хранит наши данные в формате `int64` (целочисленный формат, хранящий число в 64 битах). У Numpy есть целое множество внутренних типов данных и правил перевода из этих типов данных в другие, однако для всех наших задач будем считать, что тип данных `np.int64` идентичен типу `int` из стандартного Python

Что насчёт дробных чисел? Чтобы понять, в каком формате Numpy их сохраняет, создадим массив с дробными значениями, например числами $e$ и $\pi$, причём сделаем это с помощью констант из самой библиотеки Numpy

```Python
# массив из числа е и числа пи
arr_float = np.zeros((np.e, np.pi))

print(arr)
# [2.71828183 3.14159265]

print(arr.dtype)
# float64
```








Целые числа Numpy сохраняет в формате `int64` (целочисленный формат, хранящий число в 64 битах). 

> [!note] out of place in place (для astype)

### Индексация

### Арифметика

### Изменение формы

### Агрегации + статистики (в том числе argmax), unique

### Сохранение и загрузка (+ round / astype)

### Заключение
