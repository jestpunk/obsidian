*Васильев Никита*
### Продуктовая аналитика. ДЗ2


**2.1)** (2 балла) Сделать сешшионизацию по таблице events, с разрывом сессии через 30 минут или после смены канала привлечения.

**Ответ**
Создаём вспомогательную таблицу, хранящую булевы флаги о смене состояния (изменяется ID пользователя или источник, слишком долгая пауза между действиями) и непосредственно величину, указывающую на смену сессии. Далее выгружаем из этой таблицы все изначальные поля и считаем кумулятивную сумму "изменений номера сессии" — это и есть наш `SessionID`

```SQL
select Datetime, ID, Medium, Qty, NetSales, Profit,
       SUM(IsNextSession) OVER 
          (rows between unbounded preceding and current row)
          as Session_ID 
from
  (select ID, neighbor(ID, -1) as PrevID,
    Datetime, neighbor(Datetime, -1) as PrevDatetime,
    Medium, neighbor(Medium, -1) as PrevMedium,
  
    (ID != PrevID) as IDChangeSession,
    (Medium != PrevMedium) as MediumChangeSession,
    (Datetime - PrevDatetime >= 30 * 60) as TimeChangeSession,
    
    (MediumChangeSession or 
    TimeChangeSession or
    IDChangeSession) as IsNextSession,
     
    Qty, NetSales, Profit
  from (select * from events
  order by ID, Datetime) t) events_and_sessioning
```

- - -
&nbsp;

**2.4)** (2 балла) Сделать массив из повторенных 5 раз цифр 1, затем $5$ цифр $2$ и тд до $5$ цифр 10 (1,1,1,1,2,2,2,2, …., 10,10,10,10,10), не перечисляя все 50 цифр, а воспользовавшись функциями `arrayResize` и `arrayFlatten`. 

**Ответ**
```SQL
select arrayFlatten(arrayMap(x -> arrayResize([x], 5, x), range(1, 11))) as ans
```

- - -

&nbsp;

**2.5)** (1 балл) Для массива из прошлой задачи вывести каждый третий элемент.

**Ответ**

```SQL
-- CREATE 'ZIP' WITH GIVEN ARRAY AND IT'S INDEXES. 
-- THEN FILTER BY ITS INDEX
with (select arrayFlatten(arrayMap(x -> arrayResize([x], 5, x), range(1, 11)))) as ans,
(arrayMap(i -> [ans[i], range(1, length(ans) + 1)[i]], range(1, length(ans) + 1))) as ans_zip_indexes,
(arrayFilter(x -> x[2] % 3 = 0, ans_zip_indexes)) as zip_only_every_third

select arrayMap(x -> x[1], zip_only_every_third)
```

- - -
&nbsp;

**2.6)** (2 балла) Задача из прошлого ДЗ, но теперь ее нужно решить проще с помощью функций clickhouse: за каждый день вывести канал привлечения с максимальным GMV, и собственно сам GMV этого канала (таблица `orders`)

**Ответ**
```SQL
with GMV_per_date_and_medium as (
select ActionDate, Medium, SUM(NetSales) as GMV
from orders
group by ActionDate, Medium
order by ActionDate, Medium)
 
select argMax(Medium, GMV), max(GMV) from GMV_per_date_and_medium
group by ActionDate
```